# A0121628L
###### gui\MainController.java
``` java
	 * 
	 * @param event
	 */
	@FXML
	public void changeToHighPriority(ActionEvent event) {

		highLightLabel(highPriorityLbl);
		//Filter the list and configure the table
		filterList("high");
		
	}

	/**
```
###### gui\MainController.java
``` java
	 * @param event
	 */
	@FXML
	public void changeToMediumPriority(ActionEvent event) {
		highLightLabel(mediumPriorityLbl);
		//Filter the list and configure the table
		filterList("medium");
	}

	/**
```
###### gui\MainController.java
``` java
	 * @param event
	 */
	@FXML
	public void changeToLowPriority(ActionEvent event) {
		highLightLabel(lowPriorityLbl);
		//Filter the list and configure the table
		filterList("low");
	}

	/**
	 * Select inputTab
	 * 
```
###### gui\MainController.java
``` java
	 * @param inputTab
	 */
	public void switchToTab(String inputTab) {
		String tabName = inputTab.toLowerCase();
		SingleSelectionModel<Tab> selectionModel = tabViews.getSelectionModel();

		if (tabName.equals(POMPOM.LABEL_TASK.toLowerCase())) {
			selectionModel.select(taskTab);
			taskTabAction();
		} else if (tabName.equals(POMPOM.LABEL_COMPLETED_TASK.toLowerCase())) {
			selectionModel.select(completedTaskTab);
			completedTaskTabAction();
		} else if (tabName.equals(POMPOM.LABEL_EVENT.toLowerCase())) {
			selectionModel.select(eventTab);
			eventTabAction();
		} else if (tabName.equals(POMPOM.LABEL_COMPLETED_EVENT.toLowerCase())) {
			selectionModel.select(completedEventTab);
			completedEventTabAction();
		} else if (tabName.equals(POMPOM.LABEL_SEARCH.toLowerCase())) {
			selectionModel.select(searchTab);
			searchTabAction();
		}
	}

	/**
```
###### gui\MainController.java
``` java
	 */
	@FXML
	public void taskTabAction() {
		if (!initialized)
			return;
		GUIModel.update();
		displayList = GUIModel.getTaskList();
		configureTable();
		POMPOM.setCurrentTab(POMPOM.LABEL_TASK);
	}

	/**
```
###### gui\MainController.java
``` java
	 */
	@FXML
	public void completedTaskTabAction() {
		GUIModel.update();
		displayList = GUIModel.getTaskDoneList();
		configureTable();
		POMPOM.setCurrentTab(POMPOM.LABEL_COMPLETED_TASK);
	}

	/**
```
###### gui\MainController.java
``` java
	 */
	@FXML
	public void eventTabAction() {
		GUIModel.update();
		displayList = GUIModel.getEventList();
		configureTable();
		POMPOM.setCurrentTab(POMPOM.LABEL_EVENT);
	}

	/**
```
###### gui\MainController.java
``` java
	 */
	@FXML
	public void completedEventTabAction() {
		GUIModel.update();
		displayList = GUIModel.getEventDoneList();
		configureTable();
		POMPOM.setCurrentTab(POMPOM.LABEL_COMPLETED_EVENT);
	}

	/**
```
###### gui\MainController.java
``` java
	 */
	public void searchTabAction() {
		displayList = GUIModel.getSearchList();

		configureTable();
		POMPOM.setCurrentTab(POMPOM.LABEL_SEARCH);
	}

	/**
	 * Command triggered when enter button is pressed
	 * 
	 * @param event
	 * @throws IOException
	 */
	/**
```
###### gui\MainController.java
``` java
	 * @param event
	 * @throws IOException
	 */
	public void enterCommandFired(ActionEvent event) throws IOException {
		// Clear input string
		String input = inputCommand.getText();
		inputCommand.clear();
		// Execute command
		String msg = pompom.execute(input);
		switchToTab(POMPOM.getCurrentTab().toLowerCase());
		POMPOM.getStorage().saveStorage();
		// Update Gui
		lanuchHelp(POMPOM.showHelp);
		displayReturnMessage(msg);
		configureTable();
		setNotificationLabels();
		selectRow(input);
		inputCommand.setPromptText("Command:");
	}

	/**
```
###### gui\MainController.java
``` java
	 */
	private void configureButtons() {
		if (newTask != null) {
			newTask.setDisable(false);
		}
		if (editTask != null) {
			editTask.setDisable(true);
		}
		if (deleteTask != null) {
			deleteTask.setDisable(false);
		}
		if (enterCommand != null) {
			enterCommand.setDisable(false);
		}
	}

	/**
```
###### gui\MainController.java
``` java
	 * @param input
	 */
	public void selectRow(String input) {
		int i = input.indexOf(' ');
		if (i < 0) {
			return;
		}
		String command = input.substring(0, i);
		String restOfAction = input.substring(i + 1);
		int rowNo = table.getItems().size();
		if (command.equals("add") || command.equals("event")) {
			table.getSelectionModel().select(rowNo - 1);
			table.scrollTo(rowNo - 1);

		}
		if (command.equals("edit")) {
			int z;
			int j = restOfAction.indexOf(' ');
			if (j < 0) {
				return;
			}
			int itemNo = Integer.parseInt(restOfAction.substring(0, j));
			for (z = 0; z < rowNo - 1; z++) {
				int searchItemNo = taskID.getCellData(z).intValue();
				if (itemNo == searchItemNo) {
					break;
				}
			}
			table.getSelectionModel().select(z);
			table.scrollTo(z);
		}

	}

	/**
```
###### gui\MainController.java
``` java
	 * @param color
	 */
	private void setBackgroundColor(String color) {

		BackgroundFill myBF = new BackgroundFill(Color.valueOf(color),
				CornerRadii.EMPTY, Insets.EMPTY);
		content.setBackground(new Background(myBF));

	}

	/**
```
###### gui\MainController.java
``` java
	 * @param label
	 */
	public void highLightLabel(Label label) {
		dashboardLbl.setTextFill(Color.web(DEFAULT_LABEL_COLOR));
		settingLbl.setTextFill(Color.web(DEFAULT_LABEL_COLOR));
		highPriorityLbl.setTextFill(Color.web(DEFAULT_LABEL_COLOR));
		mediumPriorityLbl.setTextFill(Color.web(DEFAULT_LABEL_COLOR));
		lowPriorityLbl.setTextFill(Color.web(DEFAULT_LABEL_COLOR));

		label.setTextFill(Color.web(DEFAULT_HIGHLIGHT_COLOR));
	}

	/**
```
###### gui\MainController.java
``` java
	 */
	private void initializeSceneShortcuts() {
		Scene scene = mainPane.getScene();
		scene.setOnKeyPressed(shortcutHandler);
		inputCommand.addEventHandler(KeyEvent.KEY_PRESSED, inputFieldShortcut);
		table.addEventHandler(KeyEvent.KEY_PRESSED, tableShortcut);

	}

	/**
	 * Common shortcut command that shares across all items in the view
	 * 
	 * @param ke Keyevent
	 */
	public void commonShortCut(KeyEvent ke)  {
		if (UNDO_SHORTCUT.match(ke)) {
			String msg = pompom.execute(UNDO_COMMAND_STRING);
			switchToTab(POMPOM.getCurrentTab().toLowerCase());
			displayReturnMessage(msg);
			try {
				POMPOM.getStorage().saveStorage();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			configureTable();
		} else if (SWITCH_TAB_SHORTCUT.match(ke)) {
			hotkeySwitchTab();
		}		
		else if (DELETE_SHORTCUT.match(ke)) {
			Item item = table.getSelectionModel().getSelectedItem();
			if (item != null) {
				pompom.execute("delete " + item.getId());
				configureTable();
				try {
					POMPOM.getStorage().saveStorage();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				switchToTab(GUIModel.getCurrentTab());
				return;
			}

		}
		else if(NO_FILTER_SHORTCUT.match(ke)){
			switchToTab(GUIModel.getCurrentTab());
			
		}
		else if(LOW_FILTER_SHORTCUT.match(ke)){
			switchToTab(GUIModel.getCurrentTab());
			filterList("low");
		}
		else if(MEDIUM_FILTER_SHORTCUT.match(ke)){
			switchToTab(GUIModel.getCurrentTab());
			filterList("medium");
		}
		else if(HIGH_FILTER_SHORTCUT.match(ke)){
			switchToTab(GUIModel.getCurrentTab());
			filterList("high");
		}
	}

	/**
	 * Switch to next tab
	 */
	public void hotkeySwitchTab() {
		System.out.println("WORKING");
		System.out.println(GUIModel.getCurrentTab());
		System.out.println("LABEL: " + POMPOM.LABEL_TASK);

		if (GUIModel.getCurrentTab().equals(POMPOM.LABEL_TASK)) {
			System.out.println("Test");
			switchToTab(POMPOM.LABEL_COMPLETED_TASK);
			GUIModel.setCurrentTab(POMPOM.LABEL_COMPLETED_TASK);
		} 
		else if (GUIModel.getCurrentTab().equals(POMPOM.LABEL_COMPLETED_TASK)) {
			switchToTab(POMPOM.LABEL_EVENT);
			GUIModel.setCurrentTab(POMPOM.LABEL_EVENT);
		} 
		else if (GUIModel.getCurrentTab().equals(POMPOM.LABEL_EVENT)) {
			switchToTab(POMPOM.LABEL_COMPLETED_EVENT);
			GUIModel.setCurrentTab(POMPOM.LABEL_COMPLETED_EVENT);

		}  
		else if (GUIModel.getCurrentTab()
				.equals(POMPOM.LABEL_COMPLETED_EVENT)) {
			switchToTab(POMPOM.LABEL_SEARCH);
			GUIModel.setCurrentTab(POMPOM.LABEL_SEARCH);

		} 
		else if (GUIModel.getCurrentTab().equals(POMPOM.LABEL_SEARCH)) {
			switchToTab(POMPOM.LABEL_TASK);
			GUIModel.setCurrentTab(POMPOM.LABEL_TASK);
		}
	}

	/**
	 * filter the list
	 * @param priority
	 */
	public void filterList(String priority){
		GUIModel.update();
		// Filter
		switchToTab(GUIModel.getCurrentTab());
		displayList = ListClassifier
				.getSpecifiedPrirorirty(displayList, priority);
		configureTable();
	}
	/**
	 * Check whether help dialog is required to launch a not
	 * @param launched
	 */
	public void lanuchHelp(boolean launched) {
		if (launched == true) {
			POMPOM.showHelp = false;
			main.helpDialog();
		} else {
			return;
		}
	}

}
```
###### storage\Storage.java
``` java
 * This Class contains all the methods for users to read and
 *          write their storage.txt file and their settings.txt file.
 */
public class Storage {

	private final String DEFAULT_FILE_DIRECTORY = "PomPom Storage & Settings";
	private final String DEFAULT_FILE_NAME = "Storage.txt";
	private final String DEFAULT_STORAGE_FILE_PATH = DEFAULT_FILE_DIRECTORY
			+ "/" + DEFAULT_FILE_NAME;

	/** storageFile is not final as user can reset storage file path */
	private final File DEFAULT_DIRECTORY_FILE = new File(DEFAULT_FILE_DIRECTORY);
	private File storageFile = new File(DEFAULT_STORAGE_FILE_PATH);
	private String storageFilePath = DEFAULT_STORAGE_FILE_PATH;

	private final String SETTINGS_FILE_NAME = "settings.txt";
	private final String SETTINGS_FILE_PATH = DEFAULT_FILE_DIRECTORY + "/"
			+ SETTINGS_FILE_NAME;

	private final File settingsFile = new File(SETTINGS_FILE_PATH);
	private Settings settings;

	/** The main data that is being extracted to this objects */
	private UserItemList userItemList;
	private ArrayList<Item> taskList;
	private long idCounter;

	/** This library need to be initialized for the parser */
	public PrettyTimeParser timeParser;

	/** Gson Library objects to read settings and storage file in json format */
	final GsonBuilder GSON_ITEM_BUILDER = new GsonBuilder();
	final GsonBuilder GSON_SETTINGS_BUILDER = new GsonBuilder();
	private Gson gsonItem;
	private Gson gsonSettings;

	private Logger logger = Logger.getLogger("Storage");

	public Storage() throws IOException {

	}

	/**
	 * This method intializes the main objects of the storage which are the
	 * settings/storage.txt and gson objects.
	 * 
	 * @throws IOException
	 */
	public void init() throws IOException {
		initializeGsonObjects();
		initializeSettings();
		initializeStorage();
		logger.log(Level.INFO, "Initialized Storage");
		// Loading NLP library for parser for quick access
		timeParser = new PrettyTimeParser();
		timeParser.parseSyntax("next year");
	}

	// Getters and Setters
	public UserItemList getUserTaskList() {
		return userItemList;
	}

	public void setUserTaskList(UserItemList userTaskList) {
		this.userItemList = userTaskList;
	}

	public ArrayList<Item> getTaskList() {
		return taskList;
	}

	public void setTaskList(ArrayList<Item> taskList) {
		this.taskList = taskList;
	}

	public long getIdCounter() {
		idCounter = idCounter + 1;
		return idCounter;
	}

	public void setIdCounter(long idCounter) {
		this.idCounter = idCounter;
	}

	public void setStorageFile(File storageFile) {
		this.storageFile = storageFile;
	}

	public void setStorageFilePath(String storageFilePath) {
		if (storageFilePath.trim().equals("") || storageFilePath == null) {
			storageFilePath = DEFAULT_STORAGE_FILE_PATH;
			return;
		}
		this.storageFilePath = storageFilePath;
	}

	public String getStorageFilePath() {
		return storageFilePath;
	}

	public Settings getSettings() {
		return settings;
	}

	public void setSettings(Settings settings) {
		this.settings = settings;
	}

	/**
	 * This method initialize the GSON objects to read the storage text data
	 * file in JSON
	 */
	private void initializeGsonObjects() {
		GSON_ITEM_BUILDER.registerTypeAdapter(UserItemList.class,
				new ItemAdapter());
		GSON_ITEM_BUILDER.setPrettyPrinting();
		gsonItem = GSON_ITEM_BUILDER.create();

		GSON_SETTINGS_BUILDER.registerTypeAdapter(Settings.class,
				new SettingsAdapter());
		GSON_SETTINGS_BUILDER.setPrettyPrinting();
		gsonSettings = GSON_SETTINGS_BUILDER.create();
		logger.log(Level.INFO, "Gson objects Initialized with no errors");
	}

	/**
	 * This method initialize the settings if the settings.txt exist if not it
	 * creates a new file
	 * 
	 * @throws IOException
	 */
	private void initializeSettings() throws IOException {
		/** Check set directory folder exist a not if not create folder */
		checkDirectoryFolder();
		try {
			/** Check Settings file exist a not if not create file */
			checkSettingsFile();
		} catch (IOException e) {
			logger.log(Level.SEVERE, "Failure Settings Path: "
					+ SETTINGS_FILE_PATH);
			e.printStackTrace();
		}
		String settingsString = null;
		try {
			settingsString = FileHandler.getStringFromFile(SETTINGS_FILE_PATH);
		} catch (IOException e) {
			logger.log(Level.SEVERE, "Failure Reading Settings ");
			e.printStackTrace();
		}
		settings = deserializeSettingsString(settingsString);
	}

	/**
	 * This method initializes the storage.txt file(in specified location if
	 * stated in settings) or not the default location if path_directory.txt
	 * file does not exist create new storage.txt in specified directory
	 * 
	 * @throws IOException
	 */
	private void initializeStorage() throws IOException {
		// Check for user set directory in settings. If exist use directory.
		if (existStoragePath()) {
			setStorageFile(new File(settings.getStoragePath()));
			setStorageFilePath(settings.getStoragePath());
		}
		// Check for storage file if do not exist create file

		checkStorageFile();
		String storageString = FileHandler.getStringFromFile(storageFilePath);
		userItemList = deserializeStorageString(storageString);
		taskList = userItemList.getTaskArray();
		idCounter = userItemList.getIdCounter();
	}

	/**
	 * Checks storagePath exisits in settings or not
	 * 
	 * @return boolean whether storage path exist or not
	 */
	private boolean existStoragePath() {
		return settings.getStoragePath() != null;
	}

	/**
	 * This method check the directory folder of the default directory file
	 * exist or not. if the directory file does not exist it creates the
	 * directory file
	 * 
	 * @return
	 */
	private boolean checkDirectoryFolder() {
		if (!DEFAULT_DIRECTORY_FILE.exists()) {
			DEFAULT_DIRECTORY_FILE.mkdir();
			return false;
		}
		return true;
	}

	//
	/**
	 * This method check storage file exist or no if doesn't it creates a new
	 * one at the user specified directory
	 * 
	 * @return storage file existence
	 * @throws IOException
	 */
	private boolean checkStorageFile() throws IOException {
		if (!storageFile.exists()) {
			if (storageFile.getParentFile() != null) {
				storageFile.getParentFile().mkdirs();
			}

			storageFile.createNewFile();
			return false;
		}
		return true;
	}

	/**
	 * This method create settings file if it doesn't exist
	 * 
	 * @throws IOException
	 */
	private void checkSettingsFile() throws IOException {
		if (!settingsFile.exists()) {
			settingsFile.createNewFile();

		}
		return;
	}

	/**
	 * This method check whether the input string is empty or null or not
	 * 
	 * @param string
	 * @return boolean whether string is empty or not
	 */
	private boolean checkEmptyString(String string) {
		if (string.equals("") || string.equals(null)) {
			return true;
		} else {
			return false;
		}

	}

	/**
	 * This method Use the Gson library to get a Storage object from String
	 * 
	 * @param jsonString
	 * @return
	 * @throws IOException 
	 */
	private UserItemList deserializeStorageString(String jsonString) throws IOException {
		UserItemList userTaskList = null;
		if (checkEmptyString(jsonString)) {
			UserItemList utl = new UserItemList("Not Set",
					new ArrayList<Item>());
			utl.setIdCounter(0);
			taskList = new ArrayList<Item>();
			return utl;
		}
		try {
			userTaskList = gsonItem.fromJson(jsonString,
					UserItemList.class);
		} catch (Exception e) {
			System.err.println("ERROR IN STORAGE (deserializeStorageString): " + e);
			Alert alert = new Alert(AlertType.ERROR);
			alert.setTitle("Error Dialog");
			alert.setHeaderText("Look, an Error Dialog");
			alert.setContentText("ERROR READING STORAGE FILE! STORAGE FILE WAS MODIFIED WRONGlY!"
					+ "PLEASE REMOVE ILLEGAL FILE OR MODIFY FILE");
			
			alert.showAndWait();			
		}
		return userTaskList;
	}

	/**
	 * This method Use the Gson library to get a Settings object from String
	 * 
	 * @param jsonString
	 * @return
	 * @throws IOException
	 */
	private Settings deserializeSettingsString(String jsonString)
			throws IOException {
		if (checkEmptyString(jsonString)) {
			Settings defaultSettings = new Settings(DEFAULT_STORAGE_FILE_PATH,
					"eff3f6", "616060","000000");  
			defaultSettings.setStoragePath(DEFAULT_STORAGE_FILE_PATH);
			final String json = gsonSettings.toJson(defaultSettings);
			FileHandler.writeStringToFile(settingsFile, json);
			return defaultSettings;
		}
		Settings settings = null;
		
		try {
			settings = gsonSettings.fromJson(jsonString, Settings.class);
		} catch (Exception e) {
			Alert alert = new Alert(AlertType.ERROR);
			alert.setTitle("Error Dialog");
			alert.setHeaderText("Look, an Error Dialog");
			alert.setContentText("ERROR READING SETTINGS FILE! SETTINGS FILE WAS MODIFIED WRONGlY!"
					+ "PLEASE REMOVE ILLEGAL FILE OR MODIFY FILE");			
			alert.showAndWait();
			System.err.println("ERROR IN SETTINGS (deserializeSettingsString): " + e);
			
		}
		return gsonSettings.fromJson(jsonString, Settings.class);
	}

	/**
	 * This method save the current userTaskList to the storage text file
	 * 
	 * @throws IOException
	 */
	public void saveStorage() throws IOException {
		userItemList.setTaskArray(taskList);
		userItemList.setIdCounter(idCounter);
		final String json = gsonItem.toJson(userItemList);
		FileHandler.writeStringToFile(storageFile, json);
	}

	/**
	 * This method save the current Settings to the settings text file
	 * 
	 * @throws IOException
	 */
	public void saveSettings() throws IOException {
		assert settings != null : "Settings not set";
		settings.setStoragePath(storageFilePath);
		final String json = gsonSettings.toJson(settings);
		FileHandler.writeStringToFile(settingsFile, json);
	}
}
```
###### Test\GsonTest.java
``` java
 *
 */

public class GsonTest {
	// Basic example to show my teammates how the gson library works.
	// UserItemList objects for test
	GsonBuilder GSON_ITEM_BUILDER;
	Gson gsonItem;

	UserItemList taskListInput;
	Item item1;
	Item item2;
	long initialCounter;

	// Settings Objects for test
	GsonBuilder GSON_SETTINGS_BUILDER = new GsonBuilder();
	Gson gsonSettings;
	Settings settings;
	private final String TEST_STORAGE_STRING = "TEST";

	// Create a gson String builder to create a text . we register
	// UserItemList to write this
	// Object into a string. So a Gsonbuilder will create a instance of gson
	// to do this.
	@Before
	public void initObjects() {
		// Gson objects for UserItemList
		GSON_ITEM_BUILDER = new GsonBuilder();
		GSON_ITEM_BUILDER.registerTypeAdapter(UserItemList.class,
				new ItemAdapter());
		GSON_ITEM_BUILDER.setPrettyPrinting();
		gsonItem = GSON_ITEM_BUILDER.create();
		// Gson Objects for settings
		final GsonBuilder GSON_SETTINGS_BUILDER = new GsonBuilder();
		GSON_SETTINGS_BUILDER.registerTypeAdapter(Settings.class,
				new SettingsAdapter());
		GSON_SETTINGS_BUILDER.setPrettyPrinting();
		gsonSettings = GSON_SETTINGS_BUILDER.create();

		// Add userItemList data
		taskListInput = new UserItemList();
		item1 = new Item(1L, "Event", "It is a sunny day", "High",
				"I want to swim", "Done", "red label", new Date(), new Date());

		item2 = new Item(2L, "Task", "It is a rainny day", "Medium",
				"I want to study", "Undone", "blue label", new Date(),
				new Date());
		initialCounter = 0L;
		taskListInput.setUserName("Wei Lip");
		taskListInput.setIdCounter(initialCounter);
		ArrayList<Item> tArray = new ArrayList<>();
		tArray.add(item1);
		tArray.add(item2);
		taskListInput.setTaskArray(tArray);

		// Add Settings data
		settings = new Settings();
		settings.setStoragePath(TEST_STORAGE_STRING);
	}

	/********************* Helper Methods **************************************/

	public boolean isSameItemList(ArrayList<Item> listA, ArrayList<Item> listB) {
		int lengthA = listA.size();
		int lengthB = listB.size();
		boolean sameList = true;
		if (lengthA != lengthB) {
			return false;
		} else {
			// Test every aspect of the item value are equals to each other
			for (int i = 0; i < lengthA; i++) {
				// If the previous item was not the same return false.
				if (!sameList) {
					return false;
				}
				Item currentItemA = listA.get(0);
				Item currentItemB = listB.get(0);

				sameList = currentItemA.getId().equals(currentItemB.getId());
				sameList = currentItemA.getTitle().equals(
						currentItemB.getTitle());
				sameList = currentItemA.getDescription().equals(
						currentItemB.getDescription());
				sameList = currentItemA.getLabel().equals(
						currentItemB.getLabel());
				sameList = currentItemA.getPriority().equals(
						currentItemB.getPriority());
				sameList = currentItemA.getTitle().equals(
						currentItemB.getTitle());
				sameList = currentItemA.getTitle().equals(
						currentItemB.getTitle());
			}
			return sameList;
		}

	}

	/********************* Unit Tests **************************************/
	// Test the correct reading and writing of UserItemList object into the text
	// file
	@Test
	public void testGsonUserItemList() {
		final String itemJson = gsonItem.toJson(taskListInput);

		// get Object from above json string and test whether it writes to the
		// object with same values or not
		final UserItemList taskListOutput = gsonItem.fromJson(itemJson,
				UserItemList.class);

		assertEquals(taskListOutput.getUserName(), taskListInput.getUserName());
		assertEquals(taskListOutput.getIdCounter(),
				taskListInput.getIdCounter());
		ArrayList<Item> taskList1 = taskListOutput.getTaskArray();
		ArrayList<Item> taskList2 = taskListInput.getTaskArray();
		assertTrue(isSameItemList(taskList1, taskList2));

	}

	// Test the correct reading and writing of Settings object into the text
	// file
	@Test
	public void testGsonSettings() {
		final String settingsJson = gsonSettings.toJson(settings);

		final Settings settingsFromString = gsonSettings.fromJson(settingsJson,
				Settings.class);
		assertEquals(settingsFromString.getStoragePath(), TEST_STORAGE_STRING);

	}
}
```
###### Test\TestStorage.java
``` java
 *
 */
public class TestStorage {
	/** Storage directory for testing */
	private final String DEFAULT_FILE_DIRECTORY = "test";
	private final String DEFAULT_FILE_NAME = "Storage.txt";
	private final String DEFAULT_STORAGE_FILE_PATH_TESTING = DEFAULT_FILE_DIRECTORY
			+ "/" + DEFAULT_FILE_NAME;

	/** Gson testing for reading and saving */
	GsonBuilder gsonItemBuilder;
	Gson gsonItem;
	UserItemList taskListInput;

	/** Storage Items for testing */
	Item item1;
	Item item2;
	Item item3;
	Item item4;
	Storage storageStub;
	String originalStorageFilePath;

	/**
	 * Initialization of stub and item variables for adding later. Create a gson
	 * Item builder which will be used to create a JSON String from UserItemList
	 * vice-versa. So we register UserItemList to write this Object into a
	 * string. So a Gsonbuilder will create a gson instance to do this.
	 */
	@Before
	public void initGson() {

		gsonItemBuilder = new GsonBuilder();
		gsonItemBuilder.registerTypeAdapter(UserItemList.class,
				new ItemAdapter());
		gsonItemBuilder.setPrettyPrinting();
		gsonItem = gsonItemBuilder.create();
	}

	/**
	 * Initialize variables from empty storage and create 4 items for testing
	 * later. Change the storage file path to new empty folder for testing to so
	 * that it would not affect the actual folder data
	 */
	@Before
	public void initStorage() throws ParseException, IOException {

		storageStub = new Storage();
		storageStub.init();

		/** Save the orignal file path and change back to it later */
		originalStorageFilePath = storageStub.getStorageFilePath();

		/** Create new storage for test */
		File testFile = new File(DEFAULT_STORAGE_FILE_PATH_TESTING);
		testFile.delete();

		/** Set to testing location and initialize storage */
		storageStub.setStorageFilePath(DEFAULT_STORAGE_FILE_PATH_TESTING);
		storageStub.saveSettings();

		/** Reinitialize storage with new storagefile */
		storageStub.init();

		addItems(storageStub.getTaskList());
	}

	/********************* Helper Methods * @throws IOException **************************************/

	/**
	 * This method compares the 2 list in the parameters whether they have the
	 * same items or not
	 * 
	 * @param listA
	 * @param listB
	 * @return boolean value of comparng the 2 list
	 */
	public boolean isSameItemList(ArrayList<Item> listA, ArrayList<Item> listB) {
		int lengthA = listA.size();
		int lengthB = listB.size();
		boolean sameList = true;
		if (lengthA != lengthB) {
			return false;
		} else {
			/** Test every aspect of the item value are equals to each other */
			for (int i = 0; i < lengthA; i++) {
				// If the previous item was not the same return false.
				if (!sameList) {
					return false;
				}
				Item currentItemA = listA.get(0);
				Item currentItemB = listB.get(0);

				sameList = currentItemA.getId().equals(currentItemB.getId());
				sameList = currentItemA.getTitle().equals(
						currentItemB.getTitle());
				sameList = currentItemA.getDescription().equals(
						currentItemB.getDescription());
				sameList = currentItemA.getLabel().equals(
						currentItemB.getLabel());
				sameList = currentItemA.getPriority().equals(
						currentItemB.getPriority());
				sameList = currentItemA.getTitle().equals(
						currentItemB.getTitle());
				sameList = currentItemA.getTitle().equals(
						currentItemB.getTitle());
			}
			return sameList;
		}

	}

	/**
	 * This method add items for testing into the list from the param
	 * 
	 * @param list
	 * @throws ParseException
	 */
	public void addItems(ArrayList<Item> list) throws ParseException {

		SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm");
		sdf.parse("Wed, 4 Jul 2016 12:08");

		item1 = new Item(1L, "event", "Swim", "High", "Nice day", "Done",
				"red label", sdf.parse("Wed, 04 Jan 2016 12:08"),
				sdf.parse("Wed, 30 Jan 2016 12:08"));

		item2 = new Item(2L, "task", "Sleep", "Medium", "yawn", "Undone",
				"blue label", sdf.parse("Wed, 04 Jul 2016 12:08"),
				sdf.parse("Wed, 11 Jul 2016 12:08"));

		item3 = new Item(3L, "task", "Fight", "Medium", "Muay thai", "Undone",
				"blue label", sdf.parse("Wed, 01 Jul 2016 12:08"),
				sdf.parse("Wed, 10 Jul 2016 12:08"));

		item4 = new Item(4L, "task", "Mug", "Medium", "I want to study",
				"Undone", "blue label", new Date(), new Date());
		list.add(item1);
		list.add(item2);
		list.add(item3);
		list.add(item4);
	}

	/**
	 * This method add completed items into the list for testing
	 * 
	 * @param lst
	 * @throws ParseException
	 */
	public void addCompletedItems(ArrayList<Item> lst) throws ParseException {
		SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm");
		sdf.parse("Wed, 4 Jul 2016 12:08");

		Item doneItem1 = new Item(1L, "event", "Swim", "High", "Nice day",
				"completed", "red label", sdf.parse("Wed, 04 Jan 2016 12:08"),
				sdf.parse("Wed, 30 Jan 2016 12:08"));

		Item doneItem2 = new Item(2L, "task", "Sleep", "Medium", "yawn",
				"completed", "blue label", sdf.parse("Wed, 04 Jul 2016 12:08"),
				sdf.parse("Wed, 11 Jul 2016 12:08"));

		Item doneItem3 = new Item(3L, "task", "Fight", "Medium", "Muay thai",
				"completed", "blue label", sdf.parse("Wed, 01 Jul 2016 12:08"),
				sdf.parse("Wed, 10 Jul 2016 12:08"));

		Item doneItem4 = new Item(4L, "task", "Mug", "Medium",
				"I want to study", "completed", "blue label", new Date(),
				new Date());
		lst.add(doneItem1);
		lst.add(doneItem2);
		lst.add(doneItem3);
		lst.add(doneItem4);
	}

	/********************* UNIT TEST CASES * @throws IOException **************************************/

	/**
	 * Tests whether the file specified will be created when the constructor is
	 * called.
	 * 
	 * @throws IOException
	 */
	@Test
	public void testInitialization() throws IOException {
		Storage testStorage = new Storage();
		testStorage.init();
		assertNotNull(testStorage.getIdCounter());
		assertNotNull(testStorage.getStorageFilePath());
		assertNotNull(testStorage.getTaskList());
		assertNotNull(testStorage.getUserTaskList());
	}

	/**
	 * This method test whether getIdCounter increments itself a not
	 * 
	 * @throws IOException
	 */
	@Test
	public void correctIdRead() throws IOException {
		assertEquals(storageStub.getUserTaskList().getIdCounter() + 1,
				storageStub.getIdCounter());
	}

	/**
	 * The code to initialize the storageFilePath is done in the method
	 * initstorage. So now we will just check whether the path is set correctly
	 * a not
	 * 
	 * @throws SecurityException
	 * @throws IOException
	 */
	@Test
	public void testWriteToSettings() throws SecurityException, IOException {
		assertEquals(storageStub.getStorageFilePath(),
				DEFAULT_STORAGE_FILE_PATH_TESTING);
	}

	/**
	 * This method will add the items to storage and save it to the storage text
	 * file And test whether we can get back the same items using our gson file
	 * reader.
	 * 
	 * @throws IOException
	 */
	@Test
	public void testAddAndSave() throws IOException {
		// addItems(storageStub.getTaskList());
		storageStub.saveStorage();
		// Read Storage file at location storageFilePath(Tested above) and
		// check for equivalence by reading storage file with Gson
		String jsonUserItemList = FileHandler
				.getStringFromFile(DEFAULT_STORAGE_FILE_PATH_TESTING);
		UserItemList taskListOutput = gsonItem.fromJson(jsonUserItemList,
				UserItemList.class);
		assertTrue(isSameItemList(storageStub.getTaskList(),
				taskListOutput.getTaskArray()));
	}

	/**
	 * This method will delete the items to storage and save it to the storage
	 * text file And test whether we can get back the same items using our gson
	 * file reader.
	 * 
	 * @throws IOException
	 */
	@Test
	public void testDeleteAndSave() throws IOException {
		// addItems(storageStub.getTaskList());
		storageStub.getTaskList().remove(2);
		storageStub.getTaskList().remove(1);
		storageStub.saveStorage();

		// Same code as above to check for equivalence
		String jsonUserItemList = FileHandler
				.getStringFromFile(DEFAULT_STORAGE_FILE_PATH_TESTING);
		UserItemList taskListOutput = gsonItem.fromJson(jsonUserItemList,
				UserItemList.class);
		assertTrue(isSameItemList(storageStub.getTaskList(),
				taskListOutput.getTaskArray()));
	}

	/**
	 * This method will edit the items to storage and save it to the storage
	 * text file And test whether we can get back the same items using our gson
	 * file reader.
	 * 
	 * @throws IOException
	 */
	@Test
	public void testEditAndSave() throws IOException {
		// addItems(storageStub.getTaskList());
		storageStub.getTaskList().get(0).setTitle("Testing title");
		storageStub.getTaskList().get(0).setTitle("Testing title 2");
		storageStub.saveStorage();

		// Same code as above to check for equivalence
		String jsonUserItemList = FileHandler
				.getStringFromFile(DEFAULT_STORAGE_FILE_PATH_TESTING);
		UserItemList taskListOutput = gsonItem.fromJson(jsonUserItemList,
				UserItemList.class);
		assertTrue(isSameItemList(storageStub.getTaskList(),
				taskListOutput.getTaskArray()));
	}

	/**
	 * This method test whether the list classifier filters the item list
	 * correctly a not.
	 */
	@Test
	public void testListClassifierTask() {
		ArrayList<Item> temp = ListClassifier.getTaskList(storageStub
				.getTaskList());
		for (int i = 0; i < temp.size(); i++) {
			assertTrue(temp.get(i).getType().equals("task"));
		}
	}

	/**
	 * This method test whether the list classifier filters the item list
	 * correctly a not.
	 */
	@Test
	public void testListClassifierDoneTask() throws ParseException {
		addCompletedItems(storageStub.getTaskList());
		ArrayList<Item> temp = ListClassifier.getDoneTaskList(storageStub
				.getTaskList());
		for (Item item : temp) {
			assertTrue(item.getType().equals("task"));
			assertTrue(item.getStatus().equals("completed"));
		}
	}

	/**
	 * From the item list get a sublist containing all the Events from the main
	 * list
	 */
	@Test
	public void testListClassifierEvent() {
		ArrayList<Item> temp = ListClassifier.getEventList(storageStub
				.getTaskList());
		for (Item item : temp) {
			assertTrue(item.getType().equals("event"));
		}
	}

	/**
	 * This method test whether the list classifier filters the item list
	 * correctly a not.
	 */
	@Test
	public void testListClassifierDoneEvent() throws ParseException {
		addCompletedItems(storageStub.getTaskList());
		ArrayList<Item> temp = ListClassifier.getDoneEventList(storageStub
				.getTaskList());
		for (Item item : temp) {
			assertTrue(item.getType().equals("event"));
			assertTrue(item.getStatus().equals("completed"));
		}
	}

	/** Change back the settings of the original User or tester */
	@After
	public void returnToOriginalSettings() throws IOException {
		storageStub.setStorageFilePath(originalStorageFilePath);
		storageStub.saveSettings();
	}

}
```
###### utils\CheckBoxCellFactory.java
``` java
 *
 */
public class CheckBoxCellFactory implements Callback {
    @Override
    public TableCell call(Object param) {
        CheckBoxTableCell<Item,Boolean> checkBoxCell = new CheckBoxTableCell();
        
        return checkBoxCell;
    }
}
```
###### utils\FileHandler.java
``` java
 *
 */
public class FileHandler {
	/**
	 * This method rewrites the file with the given text.
	 * 
	 * 
	 * @param file
	 * @param text
	 * @throws IOException
	 */
	public static void writeStringToFile(File file, String text)
			throws IOException {
		FileWriter out = new FileWriter(file);
		out.write(text);
		out.close();
	}

	/**
	 * This method get string from the file given the file path
	 * 
	 * @param path
	 * @return
	 * @throws IOException
	 */
	public static String getStringFromFile(String path)
			throws IOException {
		byte[] encoded = Files.readAllBytes(Paths.get(path));
		return new String(encoded, StandardCharsets.UTF_8);
	}
}
```
###### utils\ListClassifier.java
``` java
 * These static methods help to return filtered list.
 */
public class ListClassifier {

	
	private static boolean checkIsToday(Date input, Date sd) {
		if(sd == null){
			return false;
		}
		Calendar cal1 = Calendar.getInstance();
		Calendar cal2 = Calendar.getInstance();
		cal1.setTime(input);
		cal2.setTime(sd);
		boolean sameDay = cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
		                  cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR);
			return sameDay;
	}

	public static String getTodayTask(ArrayList<Item> lst){
		Date currentDate = new Date();
		int counter = 0;
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);
			if(!currentTask.getType().toLowerCase().equals("task")){
				continue;
			}
			if(currentTask.getStatus().equals("ongoing")){
				counter++;
				continue;
			}
			boolean todayCheck = checkIsToday(currentDate, currentTask.getStartDate());
			// Remove this line after proper init of task and events
			if (todayCheck){
				counter++;
			}
			
		}
		return Integer.toString(counter);
	}

	public static String getTodayEvent(ArrayList<Item> lst) {
		Date currentDate = new Date();
		int counter = 0;
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);
			if(!currentTask.getType().toLowerCase().equals("event")){
				continue;
			}
			if(currentTask.getStatus().equals("ongoing")){
				counter++;
				continue;
			}
			boolean todayCheck = checkIsToday(currentDate, currentTask.getStartDate());
			// Remove this line after proper init of task and events
			if (todayCheck){
				counter++;
			}
			
		}
		return Integer.toString(counter);

	}

	public static String getOverdueTask(ArrayList<Item> lst) {
		int counter = 0;
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);
			if(currentTask.getType().toLowerCase().equals("task")
					&& currentTask.getStatus().equals("overdue")){
				counter++;
			}
		
			
		}
		return Integer.toString(counter);

	}
	/**
	 * This method filter the given list and return the item list which contains
	 * task only or empty list
	 * 
	 * @param lst
	 * @return
	 */
	public static ArrayList<Item> getTaskList(ArrayList<Item> lst) {
		ArrayList<Item> result = new ArrayList<Item>();
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);
			// Remove this line after proper init of task and event
			if (currentTask.getType() == null)
				continue;
			if (currentTask.getType().toLowerCase().equals("task")
					&& !currentTask.getStatus().equals(POMPOM.STATUS_COMPLETED)) {
				result.add(currentTask);
			}
		}
		return result;
	}

	//
	/**
	 * This method filter the given list and return the item list which contains
	 * completed task only or empty list
	 * 
	 * @param lst
	 * @return
	 */
	public static ArrayList<Item> getDoneTaskList(ArrayList<Item> lst) {
		ArrayList<Item> result = new ArrayList<Item>();
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);
			// Remove this line after proper init of task and events

			if (currentTask.getType() == null)
				continue;
			if (currentTask.getType().toLowerCase().equals("task")
					&& currentTask.getStatus().toLowerCase()
							.equals("completed")) {
				result.add(currentTask);
			}
		}
		return result;
	}

	//
	/**
	 * This method filter the given list and return the item list which contains
	 * event only or empty list
	 * 
	 * @param lst
	 * @return
	 */
	public static ArrayList<Item> getEventList(ArrayList<Item> lst) {
		ArrayList<Item> result = new ArrayList<Item>();
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);
			if (currentTask.getType() == null)
				continue;
			if (currentTask.getType().equals("Event")
					&& !currentTask.getStatus().equals(POMPOM.STATUS_COMPLETED)) {
				result.add(currentTask);
			}
		}
		return result;
	}

	/**
	 * This method filter the given list and return the item list which contains
	 * completed events only or empty list
	 * 
	 * @param lst
	 * @return
	 */
	public static ArrayList<Item> getDoneEventList(ArrayList<Item> lst) {
		ArrayList<Item> result = new ArrayList<Item>();
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);
			if (currentTask.getType() == null) {
				continue;
			}
			if (currentTask.getType().equals("Event")
					&& currentTask.getStatus().equals(POMPOM.STATUS_COMPLETED)) {
				result.add(currentTask);
			}
		}
		return result;
	}

	public static ObservableList<Item> getSpecifiedPrirorirty(ObservableList<Item> lst,
			String priority) {
		System.out.println("SIZE: "+lst.size());
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);
			System.out.println("TASK NUMBER: " + i + "\n Priority: " + currentTask.getTitle());
			
			if (currentTask.getPriority() == null) {
				i--;
				lst.remove(currentTask);
				continue;
			}
			
			if (!currentTask.getPriority().toLowerCase().equals(priority)) {
				i--;
				lst.remove(currentTask);
			}
		}
		return lst;

	}

	// public ArrayList<Item> getPendingList() {
	// ArrayList<Item> result = new ArrayList<Item>();
	// for (int i = 0; i < taskArrayList.size(); i++) {
	// Item currentTask = taskArrayList.get(i);
	// if (currentTask.getStatus().toLowerCase().equals("pending")) {
	// result.add(currentTask);
	// }
	// }
	// return result;
	// }

}
```
###### utils\Settings.java
``` java
 * Holder object which contains all the settings variables
 */
public class Settings {
	private String storagePath;
	private String backgroundColour;
	private String returnMsgColour;
	private String inputTxtColour;

	public Settings(String storagePath, String backgroundColour,
			String returnMsgColour, String inputTxtColour) {
		super();
		this.storagePath = storagePath;
		this.backgroundColour = backgroundColour;
		this.returnMsgColour = returnMsgColour;
		this.inputTxtColour = inputTxtColour;
	}

	public Settings() {

	}

	public String getReturnMsgColour() {
		return returnMsgColour;
	}

	public void setReturnMsgColour(String returnMsgColour) {
		this.returnMsgColour = returnMsgColour;
	}

	public String getInputTxtColour() {
		return inputTxtColour;
	}

	public void setInputTxtColour(String inputTxtColour) {
		this.inputTxtColour = inputTxtColour;
	}

	public String getStoragePath() {
		return storagePath;
	}

	public void setStoragePath(String storagePath) {
		this.storagePath = storagePath;
	}

	public String getBackgroundColour() {
		return backgroundColour;
	}

	public void setBackgroundColour(String backgroundColour) {
		this.backgroundColour = backgroundColour;
	}

}
```
###### utils\SettingsAdapter.java
``` java
 * This method helps write Settings into json string and read
 *          Json string to create Settings object
 */
public class SettingsAdapter extends TypeAdapter<Settings> {

	@Override
	public Settings read(JsonReader in) throws IOException {
		Settings settings = new Settings();
		in.beginObject();
		while (in.hasNext()) {
			switch (in.nextName()) {
			case "storagePath":
				settings.setStoragePath(in.nextString());
				break;
			case "backgroundColour":
				settings.setBackgroundColour(in.nextString());
				break;
			case "displayMsgColour":
				settings.setReturnMsgColour(in.nextString());
				break;
			case "inputTxtColour":
				settings.setInputTxtColour(in.nextString());
				break;
			}
		}
		in.endObject();
		return settings;
	}

	@Override
	public void write(JsonWriter out, Settings settings) throws IOException {
		out.beginObject();

		out.name("storagePath").value(settings.getStoragePath());
		out.name("backgroundColour").value(settings.getBackgroundColour());
		out.name("displayMsgColour").value(settings.getReturnMsgColour());
		out.name("inputTxtColour").value(settings.getInputTxtColour());
		
		out.endObject();
		out.close();
	}

}
```
###### utils\UserItemList.java
``` java
 *Object holder for User name item list and id counter
 *Contains getters and setters.
 */
public class UserItemList {
	private String userName;
	private long IdCounter;
	private ArrayList<Item> taskArray;
	
	public UserItemList(String userName, ArrayList<Item> taskArray) {
		this.userName = userName;
		this.taskArray = taskArray;
	}

	public UserItemList() {
	}
	
	public String getUserName() {
		return userName;
	}

	public void setUserName(String userName) {
		this.userName = userName;
	}

	public ArrayList<Item> getTaskArray() {
		return taskArray;
	}

	public void setTaskArray(ArrayList<Item> taskArray) {
		this.taskArray = taskArray;
	}
	
	public long getIdCounter() {
		return IdCounter;
	}

	public void setIdCounter(long idCounter) {
		IdCounter = idCounter;
	}
	
	// Debugging Method.
//	public void printInfo() {
//		if (userName == null)
//			System.out.println("User not set");
//		if (getTaskArray() == null){
//			System.out.println("No Task");
//			return;
//		}
//
//		System.out.println("UserName: " + userName);
//		for (int i = 0; i < taskArray.size(); i++) {
//			taskArray.get(i).printInfo();		
//
//		}
//
//	}
	

}
```
