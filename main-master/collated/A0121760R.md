# A0121760R
###### src\parser\AddParser.java
``` java
 *
 */
public class AddParser extends ArgsParser {


	private static final int INDEX_FIRST_DELIMITER = 0;
	private static final int INDEX_BEGIN = 0;
	public static final String INTERVAL_PERIOD_STRING_ANNUALLY = "annually";
	public static final String INTERVAL_PERIOD_STRING_YEARLY = "yearly";
	public static final String INTERVAL_PERIOD_STRING_FORTNIGHTLY = "fortnightly";
	public static final String INTERVAL_PERIOD_STRING_BIMONTHLY = "bimonthly";
	public static final String INTERVAL_PERIOD_STRING_MONTHLY = "monthly";
	public static final String INTERVAL_PERIOD_STRING_BIWEEKLY = "biweekly";
	public static final String INTERVAL_PERIOD_STRING_WEEKLY = "weekly";
	public static final String INTERVAL_PERIOD_STRING_DAILY = "daily";
	public static final String MESSAGE_EMPTY_ERROR = "Title cannot be empty!";
	public static final String MESSAGE_DATE_ERROR = "\"%s\" is not a valid date!";
	public static final String MESSAGE_BOUND_ERROR = "\"%s\" contains an invalid date!";
	public static final String MESSAGE_RECURRING_ERROR = "\"%s\" is not valid! Usage: \"r:<interval> until <bound date>";
	public static final String MESSAGE_EXCLUSION_ERROR = "\"%s\" is not valid! Usage: \"x:<start date> to <end date>\"";
	public static final String MESSAGE_PRIORITY_ERROR = "\"%s\" is not valid. Only high, medium or low is accepted!";
	public static final String MESSAGE_END_BEFORE_FROM = "End date cannot be before Start date!";
	public static final String MESSAGE_START_DATE_SPECIFIED = "To add a recurring task, the start date must be specified!";
	public static final String MESSAGE_DATES_SPECIFIED = "To add an event, both start and end dates must be specified!";
	public static final String MESSAGE_UNKNOWN = "Unknown error occured!";
private static final String LOG_CREATE_ADD_PARSER = "AddParser Created for \"%s\"";

	private static final String STRING_EMPTY = "";
	private static final String DATE_FROM = "from";
	private static final String DATE_END = "to";
	private static final String DATE_BOUND = "bound";
	private static final String DATE_EXCLUDE = "exclude"; 	
	private static final String DELIMITER_UNTIL = "\\s*until\\s*";
	private static final String DELIMITER_TO = "\\s* to\\s*";
	static final String PRIORITY_HIGH_CMD1 = "high";
	static final String PRIORITY_HIGH_CMD2 = "hi";
	static final String PRIORITY_HIGH_CMD3 = "h";
	static final String PRIORITY_MEDIUM_CMD1 = "medium";
	static final String PRIORITY_MEDIUM_CMD2 = "med";
	static final String PRIORITY_MEDIUM_CMD3 = "m";
	static final String PRIORITY_LOW_CMD1 = "low";
	static final String PRIORITY_LOW_CMD2 = "lo";
	static final String PRIORITY_LOW_CMD3 = "l";
	
	private static final char TAG_FROM = 'f';
	private static final char TAG_END = 'e';
	private static final char TAG_RECURRING = 'r';
	private static final char TAG_LABEL = 'l';
	private static final char TAG_PRIORITY = 'p';
	private static final char TAG_EXCEPTION = 'x';
	private static final char DELIMITER = ':';
	
	private static final int NUMBER_OF_TOKENIZED_PARTS = 2;	
	private static final int RECURRING_INTERVAL_INDEX = 0;
	private static final int RECURRING_BOUND_DATE_INDEX = 1;
	private static final int DAYS_IN_ONE_YEAR = 365;
	private static final int EXCLUSION_TOKEN_END_DATE_INDEX = 1;
	private static final int EXCLUSION_TOKEN_START_DATE_INDEX = 0;
	private static final int INTERVAL_YEARLY = 1;
	private static final int INTERVAL_BIMONTHLY = 2;
	private static final int INTERVAL_MONTHLY = 1;
	private static final int INTERVAL_BIWEEKLY = 14;
	private static final int INTERVAL_WEEKLY = 7;
	private static final int INTERVAL_DAILY = 1;

	private PrettyTimeParser timeParser = new PrettyTimeParser();
	private int[] delimiterIndexes;
	private String title;
	private String from;
	private String end;
	private String recurring;
	private String label;
	private String priority;
	private String exclusion;
	private boolean isEmptyTitle; // Condition to become true: title is empty
	private boolean isEvent;
	private boolean isFromError;
	private boolean isEndError;
	private boolean isPriorityError;
	private boolean isRecurring;
	private boolean isRecurringError;
	private boolean isBoundError;
	private boolean isTokenizeError;
	private boolean isExclusionError;
	private boolean isExclusionDateInvalid;
	private boolean isExclusionDateSeqError;
	private boolean hasExclusion;

	public AddParser(String commandArguments, boolean isEvent) {
		super(commandArguments);
		getDelimiterIndexes(this.commandArgumentsString);
		initAttributes(isEvent);
		extractDataFields();
		
		logger.log(Level.INFO, String.format(LOG_CREATE_ADD_PARSER ,
												commandArgumentsString));
	}

	/**
	 * This method gets the indexes of all delimiter characters in the command
	 * string.
	 * 
	 * @param commandArgumentsString
	 *            is the command string the user has entered.
	 */
	private void getDelimiterIndexes(String commandArgumentsString) {
		this.delimiterIndexes = new int[1000];
		int currentIndex = 0;
		for (int i = 1; i < commandArgumentsString.length(); i++) {
			char prefix = commandArgumentsString.charAt(i-1);
			if (isDelimiter(commandArgumentsString.charAt(i), prefix)) {
				delimiterIndexes[currentIndex] = i;
				currentIndex++;
			}
		}
	}
	
	/**
	 * This method initializes all attributes in this parser object to its
	 * default values. Also sets if this parser is supposed to parse for an
	 * event or a task.
	 * 
	 * @param isEvent
	 *            indicates whether the parser is supposed to parse for an
	 *            event. If true, it will parse for an event. Else, it will
	 *            parse for a task.
	 */
	private void initAttributes(boolean isEvent) {
		setIsEmptyTitle(false);
		setEvent(isEvent);
		setFromError(false);
		setEndError(false);
		setPriorityError(false);
		setRecurring(false);
		setRecurringError(false);
		setBoundError(false);
		setTokenizeError(false);
		setExclusionError(false);
		
		setExclusionDateInvalid(false);
		setExclusionDateSeqError(false);
	}

	/**
	 * This method calls other helper methods to extract all necessary data and
	 * complete the fields.
	 * 
	 * @param commandArgumentsString
	 *            is the command the user has passed into the parser.
	 */
	private void extractDataFields() {
		assertNotNull(commandArgumentsString);
		extractTitle(commandArgumentsString);
		extractOtherFields(commandArgumentsString);
	}

	/**
	 * This method gets the data from every field other than title in the
	 * command the user has passed in.
	 * 
	 * @param commandArgumentsString
	 *            is the command the user has passed in.
	 */
	private void extractOtherFields(String commandArgumentsString) {

		// going through every ":" in commandArgumentsString
		for (int i = 0; i < delimiterIndexes.length; i++) {

			// if this delimiter does not appear at the beginning of the
			// command,
			// extract the field with that delimiter.
			if (isNonZeroDelimiterIndex(i)) {
				switch (commandArgumentsString.charAt(delimiterIndexes[i] - 1)) {
				case (TAG_FROM):
					this.from = extractField(commandArgumentsString, i);
					break;
				case (TAG_END):
					this.end = extractField(commandArgumentsString, i);
					break;
				case (TAG_RECURRING):
					this.recurring = extractField(commandArgumentsString, i);
					break;
				case (TAG_LABEL):
					this.label = extractField(commandArgumentsString, i);
					break;
				case (TAG_PRIORITY):
					this.priority = extractField(commandArgumentsString, i);
					break;
				case (TAG_EXCEPTION):
					setHasExclusion(true); // Flag to run exclusion checking when set to true.
					this.exclusion = extractField(commandArgumentsString, i);
				}
			}
		}
	}

	/**
	 * This method extracts the data and stores it in the specified field from
	 * the command the user has passed in.
	 * 
	 * @param commandArgumentsString
	 *            is the command the user has passed in.
	 * @param field
	 *            is the field which the data is to be stored into.
	 * @param currentDelimiter
	 *            is the indicator of which delimiter is to be used amongst all
	 *            other delimiters in delimiterIndexes.
	 */
	private String extractField(String commandArgumentsString, int currentDelimiter) {
		String fieldData=null;
		int nextDelimiter = getNextDelimiter(currentDelimiter);
		if (isValidDelimiter(nextDelimiter)) {
		
		fieldData = commandArgumentsString.substring(getIndexAfterDelimiter(currentDelimiter), 
													getIndexBeforeDelimiter(delimiterIndexes[nextDelimiter])).trim();
			
			
		} else {
			fieldData = commandArgumentsString.substring(getIndexAfterDelimiter(currentDelimiter)).trim();
		}
		return fieldData;
	}
	
	/**
	 * This method extracts the title in the command the user has passed in and
	 * stores it in the title attribute of this parser.
	 * 
	 * @param commandArgumentsString
	 *            is the command the user has passed in.
	 */
	private void extractTitle(String commandArgumentsString) {
		if (isNonZeroDelimiterIndex(0)) {
			this.title = commandArgumentsString.substring(INDEX_BEGIN, 
										getIndexBeforeDelimiter(delimiterIndexes[INDEX_FIRST_DELIMITER])).trim();
		} else {
			this.title = commandArgumentsString.trim();
		}
		if (hasNoArguments()) {
			setIsEmptyTitle(true);
		}
	}
	
	/**
	 * This method extracts the date in the command the user has passed in and
	 * stores it in the stated date attributes of this parser.
	 * 
	 * @param dateString
	 *            is the date in string extracted by extractDataFields().
	 * 
	 * @param dateField
	 *            is the date field, used for identifying which date field to
	 *            set the error for.
	 * 
	 * @return the Date object representing the parsed start date. If no date is
	 *         found, null is returned.
	 */
	private Date parseDate(String dateString, String dateField) {
		List<Date> dateList;
		if (isNotEmptyDate(dateString)) {
			dateList = timeParser.parse(dateString);

			if (dateList.isEmpty()) {
				setDateFieldError(dateField);
				return null;
			} else {
				return dateList.get(0);
			}

		} else {
			return null;
		}
	}

	/**
	 * This method sets the specified date's error field to be true.
	 * 
	 * @param field
	 *            is the date field whose error field is to be set to be true.
	 */
	private void setDateFieldError(String field) {
		field = field.toLowerCase();
		switch (field) {
		case (DATE_FROM):
			setFromError(true);
			break;
		case (DATE_END):
			setEndError(true);
			break;
		case (DATE_BOUND):
			setBoundError(true);
			break;
		case (DATE_EXCLUDE):
			setExclusionDateInvalid(true);
			break;
		}
	}
	
	/**
	 * This method checks, matches and returns the appropriate priority the user has
	 * specified in the command.
	 * 
	 * @return
	 * 		the appropriate priority string which will be used by Command objects to 
	 * 		identify what priority the task/event belongs to.
	 */
	private String parsePriority() {

		if (isNotEmptyPriority()) {

			if (isValidHighPriorityCommand()) {
				return POMPOM.PRIORITY_HIGH;
			} else if (isValidMediumPriorityCommand()) {
				return POMPOM.PRIORITY_MED;
			} else if (isValidLowPriorityCommand()) {
				return POMPOM.PRIORITY_LOW;
			} else {
				setPriorityError(true);
				return null;
			}
			
		} else {
			return null;
		}
	}
	
	/**
	 * This method splits the input up into two parts according to the delimiter, then
	 * checks if there are valid number of tokens and returns them.
	 * 
	 * @param input
	 * 			is the input string for that is to be tokenized. 
	 * @param delimiter
	 * 			is the regex used to split the input string up
	 * @return
	 * 			an array of tokens split upn by the delimiter
	 */
	private String[] tokenize(String input, String delimiter) {
		assertNotNull(input);
		
		Scanner s = new Scanner(input);
		s.useDelimiter(delimiter);
		String[] tokens = new String[NUMBER_OF_TOKENIZED_PARTS];
		int numberOfTokens = 0;
		
		while (s.hasNext()) {
			tokens[numberOfTokens] = s.next();
			numberOfTokens++;
		}
		s.close();
		return checkAndReturnTokens(delimiter, tokens, numberOfTokens);
	}
	
	/**
	 * This method checks if the number of token is correct. If not, it identifies
	 * the appropriate errors and sets their flags to true.
	 * 
	 * @param delimiter
	 * 			is the delimiter used to tokenize the string.
	 * @param tokens
	 * 			is an array of strings containing the tokens.
	 * @param numberOfTokens
	 *			is the number of tokens created.
	 * @return
	 * 			the tokens if the appropriate number of tokens is received.
	 * 			Else, null is returned and the appropriate error flags are set.
	 */
	private String[] checkAndReturnTokens(String delimiter, String[] tokens, int numberOfTokens) {
		if (isCorrectNumberOfTokenizedParts(numberOfTokens)) {
			return tokens;
		} else {
			if (delimiter.equalsIgnoreCase(DELIMITER_UNTIL)) {
				setTokenizeError(true);
			} else {
				setExclusionError(true);
			}
			return null;
		}
	}

	/**
	 * This method parses the recurring dates from the command argument. It obtains
	 * the dates between the start and end date.
	 * 
	 * @param startDate
	 * 			represents the start of a recurring period
	 * @param endDate
	 * 			represents the end of a recurring period 
	 * 			(different from boundDate, which represents the end of everything)
	 * 
	 * @return
	 * 		an ArrayList of an ArrayList of Dates. Index 0 if the returned ArrayList contains
	 * 		the start dates. Index 1 of the returned ArrayList contains the end dates.
	 */
	private ArrayList<ArrayList<Date>> parseRecurringDates(Date startDate, Date endDate) {
		if (isNotRecurringCommand()) {
			setRecurring(false);
			return null;
		} else {

			setRecurring(true);
			String[] recurringTokens = tokenize(this.recurring, DELIMITER_UNTIL);

			if (isValidRecurringCommand()) {
				String interval = recurringTokens[RECURRING_INTERVAL_INDEX];
				Date boundDate = parseDate(recurringTokens[RECURRING_BOUND_DATE_INDEX], DATE_BOUND);

				ArrayList<Date> recurringStartDates = new ArrayList<Date>();
				ArrayList<Date> recurringEndDates = new ArrayList<Date>();

				if (isNotEmptyDate(startDate)) {
					recurringStartDates = processRecurringStartDate(startDate, interval, boundDate);
				}

				if (isNotEmptyDate(endDate)) {
					processRecurringEndDate(endDate, interval, recurringStartDates, recurringEndDates);
				}
				
				//Check if the date is within the excluded period.
				if (hasExclusionAndNonEmptyDates(startDate, endDate)) {
					processExclusion(recurringStartDates, recurringEndDates);
				}

				ArrayList<ArrayList<Date>> recurringDates = new ArrayList<ArrayList<Date>>();
			
				recurringDates.add(recurringStartDates);
				recurringDates.add(recurringEndDates);

				return recurringDates;
			} else {
				return null;
			}

		}

	}
	
	/**
	 * This method checks all start and end dates and sees if they are within the excluded
	 * period or not. If they are, the dates is/are removed from the ArrayList.
	 * 
	 * @param recurringStartDates
	 * 			is the arrayList containing all the start dates.
	 * @param recurringEndDates
	 * 			is the arrayList containing all the end dates.
	 */
	private void processExclusion(ArrayList<Date> recurringStartDates, 
									ArrayList<Date> recurringEndDates) {
		Date startDate;
		Date endDate;
	
		String[] exclusionTokens = tokenize(this.exclusion, DELIMITER_TO);

		if (hasNoExclusionErrors()) {

			Date exclusionStartDate = parseDate(exclusionTokens[EXCLUSION_TOKEN_START_DATE_INDEX], 
												DATE_EXCLUDE);
			Date exclusionEndDate = parseDate(exclusionTokens[EXCLUSION_TOKEN_END_DATE_INDEX], 
												DATE_EXCLUDE);

			if (isInvalidExclusionDates(exclusionStartDate, exclusionEndDate)) {
				setExclusionDateInvalid(true);

			} else if (exclusionStartDate.after(exclusionEndDate)) {
				//Start date should never be after end dates!
				setExclusionDateSeqError(true);

			} else {
				
				//No exclusion errors, proceed to remove the excluded dates.
				for (int i = 0; i < recurringStartDates.size(); i++) {

					startDate = recurringStartDates.get(i);
					endDate = recurringEndDates.get(i);

					if (isWithinExclusionDates(startDate, endDate, 
												exclusionStartDate, 
												exclusionEndDate)) {
						recurringStartDates.remove(i);
						recurringEndDates.remove(i);
						i--;
					}

				}
			}
		}
	}
	
	/**
	 * This method checks for the time period keywords, determines the
	 * interval and adds end dates until all start dates have end dates.
	 * 
	 * @param endDate
	 * 			is the first end date specified.
	 * @param interval
	 * 			is the interval period stated in string by the user.
	 * @param recurringStartDates
	 * 			is the arrayList containing all recurring the start dates.
	 * @param recurringEndDates
	 * 			is the arrayList containing all the recurring end dates.
	 */
	private void processRecurringEndDate(Date endDate, String interval,
									ArrayList<Date> recurringStartDates,
									ArrayList<Date> recurringEndDates) {
		
		recurringEndDates.add(endDate);
		Date nextEndDate;
		Calendar calEnd = Calendar.getInstance();
		calEnd.setTime(endDate);

		for (int i = 0; i < recurringStartDates.size(); i++) {

			if (isDailyPeriod(interval)) {
				calEnd.add(Calendar.DAY_OF_MONTH, INTERVAL_DAILY);
				
			} else if (isWeeklyPeriod(interval)) {
				calEnd.add(Calendar.DAY_OF_MONTH, INTERVAL_WEEKLY);
				
			} else if (isBiweeklyPeriod(interval)) {
				calEnd.add(Calendar.DAY_OF_MONTH, INTERVAL_BIWEEKLY);
				
			} else if (isMonthlyPeriod(interval)) {
				calEnd.add(Calendar.MONTH, INTERVAL_MONTHLY);
				
			} else if (isBiMonthlyPeriod(interval)) {
				calEnd.add(Calendar.MONTH, INTERVAL_BIMONTHLY);
				
			} else if (isYearlyPeriod(interval)) {
				calEnd.add(Calendar.YEAR, INTERVAL_YEARLY);
				
			} else {
				setRecurringError(true);
			}

			nextEndDate = calEnd.getTime();

			calEnd.setTime(nextEndDate);
			recurringEndDates.add(nextEndDate);

		}
	}

	/**
	 * 	This method checks for the time period keywords, determines the
	 * interval and adds start dates until all the bound has been reached.
	 * 
	 * @param startDate 
	 * 			is the beginning of the period specified by the user.
	 * @param interval
	 * 			is the interval period in string specified by the user.
	 * @param boundDate
	 * 			is the date when no more events should be added after that
	 * 			as specified by the the user.
	 * @return
	 * 			the arrayList of start dates within the bound period separated
	 * 			by the interval period.
	 */
	private ArrayList<Date> processRecurringStartDate(Date startDate, String interval, Date boundDate) {
		ArrayList<Date> recurringStartDates = new ArrayList<Date>();
		recurringStartDates.add(startDate);
		Date nextStartDate;
		Calendar calStart = Calendar.getInstance();
		calStart.setTime(startDate);

		for (int i = 0; i < DAYS_IN_ONE_YEAR; i++) {
			
			if (isDailyPeriod(interval)) {
				calStart.add(Calendar.DAY_OF_MONTH, INTERVAL_DAILY);
				
			} else if (isWeeklyPeriod(interval)) {
				calStart.add(Calendar.DAY_OF_MONTH, INTERVAL_WEEKLY);
				
			} else if (isBiweeklyPeriod(interval)) {
				calStart.add(Calendar.DAY_OF_MONTH, INTERVAL_BIWEEKLY);
				
			} else if (isMonthlyPeriod(interval)) {
				calStart.add(Calendar.MONTH, INTERVAL_MONTHLY);
				
			} else if (isBiMonthlyPeriod(interval)) {
				calStart.add(Calendar.MONTH, INTERVAL_BIMONTHLY);
				
			} else if (isYearlyPeriod(interval)) {
				calStart.add(Calendar.YEAR, INTERVAL_YEARLY);
				
			} else {
				setRecurringError(true);
			}

			nextStartDate = calStart.getTime();

			calStart.setTime(nextStartDate);

			if (nextStartDate.before(boundDate)) {
				recurringStartDates.add(nextStartDate);
			} else {
				break;
			}

		}
		return recurringStartDates;
	}
	
	/**
	 * This method checks for the all error flags and throws any error messages if necessary.
	 * After which, it determines whether the new item to be added is a task or event, and
	 * perform validation checks on it. If all checks are passed, a AddCommand or
	 * AddRecurringCommand will be returned.
	 * 
	 * @returns 
	 * 		an InvalidCommand if it fails any error checks. Else if its a normal add command,
	 * 		returns an AddCommand. Else if its a recurring add command, returns a RecurringAddCommand.
	 */
	public Command parse() {
		String errorMsg;
		Date startDate = parseDate(this.from, DATE_FROM);
		Date endDate = parseDate(this.end, DATE_END);
		
		String parsedPriority = parsePriority();
		ArrayList<ArrayList<Date>> recurringDate = parseRecurringDates(startDate, endDate);

		Command invalidCommand = checkForGeneralErrors(startDate, endDate);
		if (isNotNullInvalidCommand(invalidCommand)){
			return invalidCommand;
		}
		
		else if (isEvent()) {

			return processEvent(startDate, endDate, parsedPriority, recurringDate);

		} else if (!isEvent()) {
			return processTask(startDate, endDate, parsedPriority, recurringDate);

		} else {
			errorMsg = MESSAGE_UNKNOWN;
			invalidCommand = new InvalidCommand(errorMsg);
			return invalidCommand;
		}
	}

	/**
	 * This method checks if the item to be added is a valid task. If it is,
	 * it checks if the task is recurring or not, then returns the appropriate
	 * Command object.
	 * 
	 * @param startDate
	 * 			is the start date of the task specified by the user.
	 * @param endDate
	 * 			is the end date of the task specified by the user.
	 * @param parsedPriority
	 * 			is the priority of the task that has been checked and returned
	 * 			by parsePriority().
	 * @param recurringDate
	 * 			is the ArrayList of dates when the parser is parsing a recurring command.
	 * @return
	 */
	private Command processTask(Date startDate, Date endDate, String parsedPriority,
								ArrayList<ArrayList<Date>> recurringDate) {
		String errorMsg;
		Command invalidCommand;
		if (isRecurring()) {
			if (isEmptyDate(startDate)) {
				errorMsg = MESSAGE_START_DATE_SPECIFIED;
				invalidCommand = new InvalidCommand(errorMsg);
				return invalidCommand;

			} else {
				return processRecurringTask(endDate, parsedPriority, recurringDate);
			}

		} else {
			AddCommand add = new AddCommand(POMPOM.LABEL_TASK, title, null, parsedPriority, 
											POMPOM.STATUS_PENDING, label, startDate, endDate);
			return add;
		}
	}

	/**
	 * This method checks if the item to be added is a valid event. If it is,
	 * it checks if the event is recurring or not, then returns the appropriate
	 * Command object.
	 * 
	 * @param startDate
	 * 			is the start date of the task specified by the user.
	 * @param endDate
	 * 			is the end date of the task specified by the user.
	 * @param parsedPriority
	 * 			is the priority of the task that has been checked and returned
	 * 			by parsePriority().
	 * @param recurringDate
	 * 			is the ArrayList of dates when the parser is parsing a recurring command.
	 * @return
	 */
	private Command processEvent(Date startDate, Date endDate, String parsedPriority,
									ArrayList<ArrayList<Date>> recurringDate) {
		String errorMsg;
		Command invalidCommand;
		if (isInvalidExclusionDates(startDate, endDate)) {
			errorMsg = MESSAGE_DATES_SPECIFIED;
			invalidCommand = new InvalidCommand(errorMsg);
			return invalidCommand;

		} else if (isRecurring()) {
			return processRecurringEvent(parsedPriority, recurringDate);

		} else if (!isRecurring()) {
			AddCommand add = new AddCommand(POMPOM.LABEL_EVENT, title, null, parsedPriority, 
											POMPOM.STATUS_PENDING, label, startDate, endDate);
			return add;

		} else {
			errorMsg = MESSAGE_UNKNOWN;
			invalidCommand = new InvalidCommand(errorMsg);
			return invalidCommand;
		}
	}
	
	/**
	 * This method helps to convert all dates into AddCommand tasks.
	 *  
	 * @param endDate
	 * 			is the end date of the first period of the recurring task.
	 * @param parsedPriority
	 * 			is the priority of the recurring task
	 * @param recurringDate
	 * 			is the arrayList containing all recurring start and end dates.
	 * @return
	 * 		an ArrayList of AddCommands with different start and end times (if specified).
	 */
	private Command processRecurringTask(Date endDate, String parsedPriority,
											ArrayList<ArrayList<Date>> recurringDate) {
		ArrayList<Date> recurringStartDates = recurringDate.get(0);
		ArrayList<Date> recurringEndDates = recurringDate.get(1);
		ArrayList<AddCommand> addList = new ArrayList<AddCommand>();
		for (int i = 0; i < recurringStartDates.size(); i++) {
			if (isEmptyDate(endDate)) {
				AddCommand toAdd = new AddCommand(POMPOM.LABEL_TASK, title, null, parsedPriority, 
													POMPOM.STATUS_PENDING, label, recurringStartDates.get(i), 
													null, true);
				addList.add(toAdd);
			} else {
				AddCommand toAdd = new AddCommand(POMPOM.LABEL_TASK, title, null, parsedPriority,
													POMPOM.STATUS_PENDING, label, recurringStartDates.get(i), 
													recurringEndDates.get(i), true);
				addList.add(toAdd);
			}
		}

		AddRecurringCommand addRecurring = new AddRecurringCommand(addList);
		return addRecurring;
	}

	/**
	 * This method helps to convert all dates into AddCommand events.
	 *  
	 * @param endDate
	 * 			is the end date of the first period of the recurring event.
	 * @param parsedPriority
	 * 			is the priority of the recurring event.
	 * @param recurringDate
	 * 			is the arrayList containing all recurring start and end dates.
	 * @return
	 * 		an ArrayList of AddCommands with different start and end times (if specified).
	 */
	private Command processRecurringEvent(String parsedPriority, ArrayList<ArrayList<Date>> recurringDate) {
		ArrayList<Date> recurringStartDates = recurringDate.get(0);
		ArrayList<Date> recurringEndDates = recurringDate.get(1);
		ArrayList<AddCommand> addList = new ArrayList<AddCommand>();
		for (int i = 0; i < recurringStartDates.size(); i++) {

			AddCommand toAdd = new AddCommand(POMPOM.LABEL_EVENT, title, null, parsedPriority,
												POMPOM.STATUS_PENDING, label, recurringStartDates.get(i), 
												recurringEndDates.get(i), true);
			addList.add(toAdd);
		}

		AddRecurringCommand addRecurring = new AddRecurringCommand(addList);
		return addRecurring;
	}

	/**
	 * This method will check if any flags were raised throughout the parsing process.
	 * If there is any raised flag, an InvalidCommand object will be returned.
	 * 
	 * @param startDate
	 * 			is the start date specified by the user.
	 * @param endDate
	 * 			is the end date specified by the user.
	 * @return
	 * 		null if there is no raised flags. InvalidCommand if there is any raised
	 * `	error flags.
	 */
	private Command checkForGeneralErrors(Date startDate, Date endDate) {
		String errorMsg;
		InvalidCommand invalidCommand;
		if (isEmptyArguments() || isEmptyTitle) {
			errorMsg = MESSAGE_EMPTY_ERROR;
			invalidCommand = new InvalidCommand(errorMsg);
			return invalidCommand;

		} else if (startDate != null && endDate != null && endDate.before(startDate)) {
			errorMsg = MESSAGE_END_BEFORE_FROM;
			invalidCommand = new InvalidCommand(errorMsg);
			return invalidCommand;

		} else if (isFromError()) {
			errorMsg = String.format(MESSAGE_DATE_ERROR, this.from);
			invalidCommand = new InvalidCommand(errorMsg);
			return invalidCommand;

		} else if (isEndError()) {
			errorMsg = String.format(MESSAGE_DATE_ERROR, this.end);
			invalidCommand = new InvalidCommand(errorMsg);
			return invalidCommand;

		} else if (isPriorityError()) {
			errorMsg = String.format(MESSAGE_PRIORITY_ERROR, this.priority);
			invalidCommand = new InvalidCommand(errorMsg);
			return invalidCommand;

		} else if (isRecurringError() || isTokenizeError) {
			errorMsg = String.format(MESSAGE_RECURRING_ERROR, this.recurring);
			invalidCommand = new InvalidCommand(errorMsg);
			return invalidCommand;

		} else if (isBoundError()) {
			errorMsg = String.format(MESSAGE_BOUND_ERROR, this.recurring);
			invalidCommand = new InvalidCommand(errorMsg);
			return invalidCommand;

		} else if (isExclusionError()) {
			errorMsg = String.format(MESSAGE_EXCLUSION_ERROR, this.exclusion);
			invalidCommand = new InvalidCommand(errorMsg);
			return invalidCommand;

		} else if (isExclusionDateInvalid()) {
			errorMsg = String.format(MESSAGE_DATE_ERROR, this.exclusion);
			invalidCommand = new InvalidCommand(errorMsg);
			return invalidCommand;

		} else if (isExclusionDateSeqError()) {
			errorMsg = MESSAGE_END_BEFORE_FROM;
			invalidCommand = new InvalidCommand(errorMsg);
			return invalidCommand;
		} else {
			return null;
		}
	}
	
	//GETTERS AND SETTERS

	/**
	 * Gets the index of the character that is before the next delimiter.
	 * 
	 * @param nextDelimiter
	 *            is the index of the chosen delimiter.
	 * @return the index before the chosen delimiter
	 */
	private int getIndexBeforeDelimiter(int delimiterIndex) {
		return delimiterIndex - 1;
	}

	/**
	 * Gets the index of the character after the currently selected delimiter.
	 * 
	 * @param currentDelimiter
	 *            is the index which the desired delimiter appears in the
	 *            delimiter indexes array.
	 * @return the index after the index of the desired delimiter in the
	 *         delimiter index array.
	 */
	private int getIndexAfterDelimiter(int chosenDelimiter) {
		return delimiterIndexes[chosenDelimiter] + 1;
	}
	private boolean isValidRecurringCommand() {
		return !isRecurringError() && !isBoundError() && !isTokenizeError();
	}
	
	private int getNextDelimiter(int currentDelimiter) {
		return currentDelimiter + 1;
	}

	private boolean isNonZeroDelimiterIndex(int selectDelimiter) {
		return delimiterIndexes[selectDelimiter] != 0;
	}

	private boolean isDelimiter(char character, char selectedPrefix) {
		boolean isValidPrefix=false;
		char[] prefixes = {TAG_FROM, TAG_END, TAG_RECURRING,
							TAG_LABEL, TAG_PRIORITY, TAG_EXCEPTION};
		
		for (char currentPrefix: prefixes){
			if (selectedPrefix == currentPrefix){
				isValidPrefix=true;
			}
		}
		return (character == DELIMITER && isValidPrefix);
	}

	private boolean isEmptyArguments() {
		return commandArgumentsString.equals(STRING_EMPTY);
	}

	private boolean isNotEmptyDate(String dateField) {
		return dateField != null;
	}
	
	private boolean isNotEmptyDate(Date dateField) {
		return dateField != null;
	}
	
	private boolean isEmptyDate(Date dateField) {
		return dateField == null;
	}

	private void setIsEmptyTitle(boolean isEmptyTitle) {
		this.isEmptyTitle = isEmptyTitle;
	}

	private boolean isEvent() {
		return isEvent;
	}

	private void setEvent(boolean isEvent) {
		this.isEvent = isEvent;
	}

	private boolean isFromError() {
		return isFromError;
	}

	private void setFromError(boolean isFromError) {
		this.isFromError = isFromError;
	}

	private boolean isEndError() {
		return isEndError;
	}

	private void setEndError(boolean isEndError) {
		this.isEndError = isEndError;
	}

	private boolean isPriorityError() {
		return isPriorityError;
	}

	private void setPriorityError(boolean isPriorityError) {
		this.isPriorityError = isPriorityError;
	}

	private boolean isRecurring() {
		return isRecurring;
	}

	private void setRecurring(boolean isRecurring) {
		this.isRecurring = isRecurring;
	}

	private boolean isRecurringError() {
		return isRecurringError;
	}

	private void setRecurringError(boolean isRecurringError) {
		this.isRecurringError = isRecurringError;
	}

	private boolean isBoundError() {
		return isBoundError;
	}

	private void setBoundError(boolean isBoundError) {
		this.isBoundError = isBoundError;
	}

	private boolean isTokenizeError() {
		return isTokenizeError;
	}

	private void setTokenizeError(boolean isTokenizeError) {
		this.isTokenizeError = isTokenizeError;
	}

	private boolean isExclusionError() {
		return isExclusionError;
	}

	private void setExclusionError(boolean isExceptionError) {
		this.isExclusionError = isExceptionError;
	}

	private boolean isExclusionDateInvalid() {
		return isExclusionDateInvalid;
	}

	private void setExclusionDateInvalid(boolean isExclusionDateInvalid) {
		this.isExclusionDateInvalid = isExclusionDateInvalid;
	}

	private boolean hasExclusion() {
		return hasExclusion;
	}

	private void setHasExclusion(boolean hasException) {
		this.hasExclusion = hasException;
	}

	private boolean isExclusionDateSeqError() {
		return isExclusionDateSeqError;
	}

	private void setExclusionDateSeqError(boolean isExclusionDateSeqError) {
		this.isExclusionDateSeqError = isExclusionDateSeqError;
	}
	
	private boolean isCorrectNumberOfTokenizedParts(int numberOfTokens) {
		return numberOfTokens == NUMBER_OF_TOKENIZED_PARTS;
	}
	
	private boolean isWithinExclusionDates(Date startDate, Date endDate, Date exclusionStartDate,
			Date exclusionEndDate) {
		return exclusionStartDate.before(endDate) && exclusionEndDate.after(startDate);
	}

	private boolean isInvalidExclusionDates(Date exclusionStartDate, Date exclusionEndDate) {
		return exclusionStartDate == null || exclusionEndDate == null;
	}

	private boolean hasNoExclusionErrors() {
		return !isExclusionError() && !isExclusionDateInvalid();
	}
	
	private boolean isYearlyPeriod(String interval) {
		return interval.equalsIgnoreCase(INTERVAL_PERIOD_STRING_ANNUALLY) ||
				interval.equalsIgnoreCase(INTERVAL_PERIOD_STRING_YEARLY);
	}

	private boolean isBiMonthlyPeriod(String interval) {
		return interval.equalsIgnoreCase(INTERVAL_PERIOD_STRING_BIMONTHLY);
	}

	private boolean isMonthlyPeriod(String interval) {
		return interval.equalsIgnoreCase(INTERVAL_PERIOD_STRING_MONTHLY);
	}

	private boolean isDailyPeriod(String interval) {
		return interval.equalsIgnoreCase(INTERVAL_PERIOD_STRING_DAILY);
	}

	private boolean isWeeklyPeriod(String interval) {
		return interval.equalsIgnoreCase(INTERVAL_PERIOD_STRING_WEEKLY);
	}

	private boolean isBiweeklyPeriod(String interval) {
		return interval.equalsIgnoreCase(INTERVAL_PERIOD_STRING_BIWEEKLY) || 
				interval.equalsIgnoreCase(INTERVAL_PERIOD_STRING_FORTNIGHTLY);
	}

	private boolean isNotRecurringCommand() {
		return this.recurring == null;
	}
	
	private boolean isNotNullInvalidCommand(Command invalidCommand) {
		return invalidCommand!=null;
	}
	
	private boolean hasExclusionAndNonEmptyDates(Date startDate, Date endDate) {
		return hasExclusion() && isNotEmptyDate(startDate) && isNotEmptyDate(endDate);
	}

	private boolean isValidDelimiter(int nextDelimiter) {
		return nextDelimiter < 6 && isNonZeroDelimiterIndex(nextDelimiter);
	}

	private boolean hasNoArguments() {
		return isEmptyArguments() || this.title.trim().equals(STRING_EMPTY);
	}
	
	private boolean isNotEmptyPriority() {
		return this.priority != null;
	}

	private boolean isValidHighPriorityCommand() {
		//Appropriate commands are: "high", "hi", "h"
		return this.priority.equalsIgnoreCase(PRIORITY_HIGH_CMD1) 
				|| this.priority.equalsIgnoreCase(PRIORITY_HIGH_CMD2) 
				|| this.priority.equalsIgnoreCase(PRIORITY_HIGH_CMD3);
	}
	
	private boolean isValidMediumPriorityCommand() {
		//Appropriate commands are: "medium", "med", "m"
		return this.priority.equalsIgnoreCase(PRIORITY_MEDIUM_CMD1) 
				|| this.priority.equalsIgnoreCase(PRIORITY_MEDIUM_CMD2) 
				|| this.priority.equalsIgnoreCase(PRIORITY_MEDIUM_CMD3);
	}
	
	private boolean isValidLowPriorityCommand() {
		//Appropriate commands are: "low", "lo", "l"
		return this.priority.equalsIgnoreCase(PRIORITY_LOW_CMD1) 
				|| this.priority.equalsIgnoreCase(PRIORITY_LOW_CMD2) 
				|| this.priority.equalsIgnoreCase(PRIORITY_LOW_CMD3);
	}
}
```
###### src\parser\AddParserTest.java
``` java
 *
 */

public class AddParserTest {

	POMPOM pompom = new POMPOM();
	TestSystem test = new TestSystem();
	PrettyTimeParser timeParser = pompom.timeParser;
	
	/*
	 * For Reference:
	 * 
	 * Non-Recurring:
	 * 
	 * AddCommand(Task/Event, title, description,
	 * 				priority, status(pending/overdue),label
	 * 				startDate, endDate, isRecurring)
	 * 
	 * Recurring:
	 * 
	 * AddCommand(Task/Event, title, description, 
	 * 			priority, status(pending/overdue), label, 
	 * 			recurringStartDates.get(i), recurringEndDates.get(i), 
	 * 			isRecurring);
	 *
	 */
	
	//Good Cases
	@Test
	public void testTitleOnly() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("do cs2103",false);
		addParser.parse().execute();
	
		//Expected Case
		Command callFromCommand = new AddCommand(POMPOM.LABEL_TASK, "do cs2103", null, null, 
										POMPOM.STATUS_PENDING, null, null, 
										null, false);
		callFromCommand.execute();
		
		//Get the tasks and compare
		Item reality = taskList.get(0);
		Item expected = taskList.get(1);
		assertTrue(test.testIsSameItem(expected, reality));
	}
	
	@Test
	public void testTitleAndStartDate() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("do cs2103 f:tomorrow",false);
		addParser.parse().execute();
	
		//Expected Case
		Date startDate = getDate("tomorrow");
		Command callFromCommand = new AddCommand(POMPOM.LABEL_TASK, "do cs2103", null, null, 
										POMPOM.STATUS_PENDING, null, startDate, 
										null, false);
		callFromCommand.execute();
		
		//Get the tasks and compare
		Item reality = taskList.get(0);
		Item expected = taskList.get(1);
		assertTrue(test.testIsSameItem(expected, reality));
	}
	
	@Test
	public void testTitleAndEndDate() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("do cs2103 e:20 april",false);
		addParser.parse().execute();
	
		//Expected Case
		Date endDate = getDate("20 april");
		Command callFromCommand = new AddCommand(POMPOM.LABEL_TASK, "do cs2103", null, null, 
										POMPOM.STATUS_PENDING, null, null, 
										endDate, false);
		callFromCommand.execute();
		
		//Get the tasks and compare
		Item reality = taskList.get(0);
		Item expected = taskList.get(1);
		assertTrue(test.testIsSameItem(expected, reality));
	}
	
	@Test
	public void testTitleAndLabel() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("do cs2103 l:homework",false);
		addParser.parse().execute();
	
		//Expected Case
		Command callFromCommand = new AddCommand(POMPOM.LABEL_TASK, "do cs2103", null, null, 
										POMPOM.STATUS_PENDING, "homework", null, 
										null, false);
		callFromCommand.execute();
		
		//Get the tasks and compare
		Item reality = taskList.get(0);
		Item expected = taskList.get(1);
		assertTrue(test.testIsSameItem(expected, reality));
	}
	
	@Test
	public void testTitleAndPriority() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("do cs2103 p:h",false);
		addParser.parse().execute();
	
		//Expected Case
		Command callFromCommand = new AddCommand(POMPOM.LABEL_TASK, "do cs2103", null, "high", 
										POMPOM.STATUS_PENDING, null, null, 
										null, false);
		callFromCommand.execute();
		
		//Get the tasks and compare
		Item reality = taskList.get(0);
		Item expected = taskList.get(1);
		assertTrue(test.testIsSameItem(expected, reality));
	}
	
	@Test
	public void testTitleAndStartAndEndDate() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("do cs2103 f:tomorrow e:20 april",false);
		addParser.parse().execute();
	
		//Expected Case
		Date startDate = getDate("tomorrow");
		Date endDate = getDate("20 april");
		Command callFromCommand = new AddCommand(POMPOM.LABEL_TASK, "do cs2103", null, null, 
										POMPOM.STATUS_PENDING, null, startDate, 
										endDate, false);
		callFromCommand.execute();
		
		//Get the tasks and compare
		Item reality = taskList.get(0);
		Item expected = taskList.get(1);
		assertTrue(test.testIsSameItem(expected, reality));
	}
	
	@Test
	public void testTitleAndStartAndEndDateWiithLabel() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("do cs2103 f:tomorrow e:20 april l:homework",false);
		addParser.parse().execute();
	
		//Expected Case
		Date startDate = getDate("tomorrow");
		Date endDate = getDate("20 april");
		Command callFromCommand = new AddCommand(POMPOM.LABEL_TASK, "do cs2103", null, null, 
										POMPOM.STATUS_PENDING, "homework", startDate, 
										endDate, false);
		callFromCommand.execute();
		
		//Get the tasks and compare
		Item reality = taskList.get(0);
		Item expected = taskList.get(1);
		assertTrue(test.testIsSameItem(expected, reality));
	}
	
	@Test
	public void testTitleAndStartAndEndDateWiithPriority() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("do cs2103 f:tomorrow e:20 april p:hi",false);
		addParser.parse().execute();
	
		//Expected Case
		Date startDate = getDate("tomorrow");
		Date endDate = getDate("20 april");
		Command callFromCommand = new AddCommand(POMPOM.LABEL_TASK, "do cs2103", null, "high", 
										POMPOM.STATUS_PENDING, null, startDate, 
										endDate, false);
		callFromCommand.execute();
		
		//Get the tasks and compare
		Item reality = taskList.get(0);
		Item expected = taskList.get(1);
		assertTrue(test.testIsSameItem(expected, reality));
	}
	
	@Test
	public void testFullCommand() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("do cs2103 f:tomorrow e:20 april l:homework p:h",false);
		addParser.parse().execute();
	
		//Expected Case
		Date startDate = getDate("tomorrow");
		Date endDate = getDate("20 april");
		Command callFromCommand = new AddCommand(POMPOM.LABEL_TASK, "do cs2103", null, "high", 
										POMPOM.STATUS_PENDING, "homework", startDate, 
										endDate, false);
		callFromCommand.execute();
		
		//Get the tasks and compare
		Item reality = taskList.get(0);
		Item expected = taskList.get(1);
		assertTrue(test.testIsSameItem(expected, reality));
	}
	
	@Test
	public void testBasicRecurring() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("do cs2103 f:12 april e:13 april r:daily until 16 april",false);
		addParser.parse().execute();
	
		//Expected Case
		ArrayList<AddCommand> recurringAddCommands = new ArrayList<AddCommand>();
		ArrayList<Date> startDateList = new ArrayList<Date>();
		startDateList.add(getDate("12 april"));
		startDateList.add(getDate("13 april"));
		startDateList.add(getDate("14 april"));
		startDateList.add(getDate("15 april"));
		startDateList.add(getDate("16 april"));
		
		ArrayList<Date> endDateList = new ArrayList<Date>();
		endDateList.add(getDate("13 april"));
		endDateList.add(getDate("14 april"));
		endDateList.add(getDate("15 april"));
		endDateList.add(getDate("16 april"));
		endDateList.add(getDate("17 april"));
		
		for (int i=0; i<startDateList.size(); i++){
			recurringAddCommands.add(new AddCommand(POMPOM.LABEL_TASK, "do cs2103", 
										null, null, POMPOM.STATUS_PENDING, null, 
										startDateList.get(i), endDateList.get(i), true));
		}
		
		Command callFromCommand = new AddRecurringCommand(recurringAddCommands);
		callFromCommand.execute();
		
		//Get the tasks and compare
		Item reality;
		Item expected;
		for (int i=0; i<startDateList.size(); i++){
			reality = taskList.get(i);
			expected = taskList.get(i+startDateList.size());
			assertTrue(test.testIsSameItem(expected, reality));
		}
		
	}
	
	@Test
	public void testBasicRecurringWithExclude() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("do cs2103 f:12 april e:13 april r:daily until 16 april x:12 april to 13 april",false);
		addParser.parse().execute();
	
		//Expected Case
		ArrayList<AddCommand> recurringAddCommands = new ArrayList<AddCommand>();
		ArrayList<Date> startDateList = new ArrayList<Date>();
		startDateList.add(getDate("14 april"));
		startDateList.add(getDate("15 april"));
		startDateList.add(getDate("16 april"));
		
		ArrayList<Date> endDateList = new ArrayList<Date>();
		endDateList.add(getDate("15 april"));
		endDateList.add(getDate("16 april"));
		endDateList.add(getDate("17 april"));
		
		for (int i=0; i<startDateList.size(); i++){
			recurringAddCommands.add(new AddCommand(POMPOM.LABEL_TASK, "do cs2103", 
										null, null, POMPOM.STATUS_PENDING, null, 
										startDateList.get(i), endDateList.get(i), true));
		}
		
		Command callFromCommand = new AddRecurringCommand(recurringAddCommands);
		callFromCommand.execute();
		
		//Get the tasks and compare
		Item reality;
		Item expected;;
		for (int i=0; i<startDateList.size(); i++){
			reality = taskList.get(i);
			expected = taskList.get(i+startDateList.size());
			assertTrue(test.testIsSameItem(expected, reality));
		}
		
	}
	
	//Corner cases
	@Test
	public void testInvalidDelimiters() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("k:try this",false);
		addParser.parse().execute();
	
		//Expected Case
		Command callFromCommand = new AddCommand(POMPOM.LABEL_TASK, "k:try this", null, null, 
										POMPOM.STATUS_PENDING, null, null, 
										null, false);
		callFromCommand.execute();
		
		//Get the tasks and compare
		Item reality = taskList.get(0);
		Item expected = taskList.get(1);
		assertTrue(test.testIsSameItem(expected, reality));
	}
	
	@Test
	public void testRemoveSpaces() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("asd f:today e:tomorrow l:Work p:hr:daily until 17 aprx:14 apr to 15 apr",false);
		addParser.parse().execute();
	
		//Expected Case
		ArrayList<AddCommand> recurringAddCommands = new ArrayList<AddCommand>();
		ArrayList<Date> startDateList = new ArrayList<Date>();
		startDateList.add(getDate("11 april"));
		startDateList.add(getDate("12 april"));
		startDateList.add(getDate("13 april"));
		startDateList.add(getDate("16 april"));
		startDateList.add(getDate("17 april"));
		
		
		ArrayList<Date> endDateList = new ArrayList<Date>();
		endDateList.add(getDate("12 april"));
		endDateList.add(getDate("13 april"));
		endDateList.add(getDate("14 april"));
		endDateList.add(getDate("17 april"));
		endDateList.add(getDate("18 april"));

		
		for (int i=0; i<startDateList.size(); i++){
			recurringAddCommands.add(new AddCommand(POMPOM.LABEL_TASK, "asd", 
										null, "high", POMPOM.STATUS_PENDING, "Work", 
										startDateList.get(i), endDateList.get(i), true));
		}
		
		Command callFromCommand = new AddRecurringCommand(recurringAddCommands);
		callFromCommand.execute();
		
		//Get the tasks and compare
		Item reality;
		Item expected;
		for (int i=0; i<startDateList.size(); i++){
			reality = taskList.get(i);
			expected = taskList.get(i+startDateList.size());
			assertTrue(test.testIsSameItem(expected, reality));
		}
		
	}
	
	//Bad Cases
	@Test
	public void testEmptyArguments() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser(null,false);
		addParser.parse().execute();
	
		//Expected Case
		Command invalidCommand = new InvalidCommand(AddParser.MESSAGE_EMPTY_ERROR);
		assertEquals(AddParser.MESSAGE_EMPTY_ERROR,invalidCommand.execute());
		
	}
	
	@Test
	public void testSpaceArgument() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser(" ",false);
		addParser.parse().execute();
	
		//Expected Case
		Command invalidCommand = new InvalidCommand(AddParser.MESSAGE_EMPTY_ERROR);
		assertEquals(AddParser.MESSAGE_EMPTY_ERROR,invalidCommand.execute());
		
	}
	
	@Test
	public void testInvalidEndDateFull() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("title lol f:tomorrow e:the day after r:weekly"
											+ "until 30 april x:13 april to 24 april",false);
		addParser.parse().execute();
	
		//Expected Case
		Command invalidCommand = new InvalidCommand(String.format(AddParser.MESSAGE_DATE_ERROR, "the day after"));
		assertEquals(String.format(AddParser.MESSAGE_DATE_ERROR, "the day after"), invalidCommand.execute());
		
	}
	
	@Test
	public void testInvalidFromDate() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("add test f:lol",false);
		addParser.parse().execute();
	
		//Expected Case
		Command invalidCommand = new InvalidCommand(String.format(AddParser.MESSAGE_DATE_ERROR, "lol"));
		assertEquals(String.format(AddParser.MESSAGE_DATE_ERROR, "lol"), invalidCommand.execute());
	}
	
	@Test
	public void testInvalidEndDate() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("add test e:lol",false);
		addParser.parse().execute();
	
		//Expected Case
		Command invalidCommand = new InvalidCommand(String.format(AddParser.MESSAGE_DATE_ERROR, "lol"));
		assertEquals(String.format(AddParser.MESSAGE_DATE_ERROR, "lol"), invalidCommand.execute());
	}
	
	@Test
	public void testInvalidFromAndEndDate() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("add test f:lol e:lol",false);
		addParser.parse().execute();
	
		//Expected Case
		Command invalidCommand = new InvalidCommand(String.format(AddParser.MESSAGE_DATE_ERROR, "lol"));
		assertEquals(String.format(AddParser.MESSAGE_DATE_ERROR, "lol"), invalidCommand.execute());
	}
	
	@Test
	public void testInvalidEndDateValidStartDate() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("add test f:tomorrow e:lol",false);
		addParser.parse().execute();
	
		//Expected Case
		Command invalidCommand = new InvalidCommand(String.format(AddParser.MESSAGE_DATE_ERROR, "lol"));
		assertEquals(String.format(AddParser.MESSAGE_DATE_ERROR, "lol"), invalidCommand.execute());
	}
	
	@Test
	public void testInvalidStartDateValidEndDate() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("add test f:lol e:tomorrow",false);
		addParser.parse().execute();
	
		//Expected Case
		Command invalidCommand = new InvalidCommand(String.format(AddParser.MESSAGE_DATE_ERROR, "lol"));
		assertEquals(String.format(AddParser.MESSAGE_DATE_ERROR, "lol"), invalidCommand.execute());
	}
	
	@Test
	public void testEmptyStartDate() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("add test f: e:tomorrow",false);
		addParser.parse().execute();
	
		//Expected Case
		Command invalidCommand = new InvalidCommand(String.format(AddParser.MESSAGE_DATE_ERROR, ""));
		assertEquals(String.format(AddParser.MESSAGE_DATE_ERROR, ""), invalidCommand.execute());
	}
	
	@Test
	public void testEmptyEndDate() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("add test f:tomorrow e:",false);
		addParser.parse().execute();
	
		//Expected Case
		Command invalidCommand = new InvalidCommand(String.format(AddParser.MESSAGE_DATE_ERROR, ""));
		assertEquals(String.format(AddParser.MESSAGE_DATE_ERROR, ""), invalidCommand.execute());
	}
	
	@Test
	public void testAddEmptyLabelNoTitle() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("add l:",false);
		addParser.parse().execute();
	
		//Expected Case
		Command invalidCommand = new InvalidCommand(AddParser.MESSAGE_EMPTY_ERROR);
		assertEquals(String.format(AddParser.MESSAGE_EMPTY_ERROR), invalidCommand.execute());
	}
	
	
	@Test
	public void testAddEmptyPriorityNoTitle() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		
		//Reality Case
		AddParser addParser = new AddParser("add p:",false);
		addParser.parse().execute();
	
		//Expected Case
		Command invalidCommand = new InvalidCommand(AddParser.MESSAGE_EMPTY_ERROR);
		assertEquals(String.format(AddParser.MESSAGE_EMPTY_ERROR), invalidCommand.execute());
	}
	
	
	//Helper Methods
	
	private Date getDate(String dateString) {
		return timeParser.parseSyntax(dateString).get(0).getDates().get(0);
	}


}
```
###### src\parser\ArgsParser.java
``` java
 *
 */
public class ArgsParser {
	
	protected static Logger logger = Logger.getLogger("Parser");
	
	protected boolean hasNoArguments = false; 
	protected String commandArgumentsString;
	
	public ArgsParser(String commandArguments){
		commandArgumentsString = commandArguments;
		if (isNullArgument()){
			commandArgumentsString = "";
		}
	}

	private boolean isNullArgument() {
		return commandArgumentsString == null;
	}
	
	public Command invalidArgs(){
		return new InvalidCommand(commandArgumentsString);
	}
}
```
###### src\parser\DeleteParser.java
``` java
 *
 */
public class DeleteParser extends ArgsParser{
	
	private static final String LOG_CREATE_DELETE_PARSER = "DeleteParser Created for \"%s\"";
	static final String MESSAGE_INVALID_ID = "The task ID is invalid!";
	
	private Long itemID;
	private Command InvalidCommand = null;
	
	public DeleteParser(String userCommand){
		super(userCommand);
		assertNotNull(commandArgumentsString);
		setItemId();
		logger.log(Level.INFO, String.format(LOG_CREATE_DELETE_PARSER ,
												commandArgumentsString));
	}
	
	/**
	 * This method will return the appropriate Command to be processed
	 * by the Command class.
	 * 
	 * @return DelCommand() if the ID is an long. InvalidCommand if it is not.
	 */
	public Command parse(){
		if (isNullInvalidCommand()){
			itemID = new Long(itemID);
			return new DelCommand(itemID);
		} else{
			return InvalidCommand;
		}
	}
	
	/**
	 * This method attempts to see if the ID is a valid integer or not. If it is,
	 * the itemID field is set. Else, the invalidCommand field will be set.
	 */
	public void setItemId(){
		try{
			//checks if itemID is an long.
			itemID = Long.parseLong(commandArgumentsString);
			
		} catch (Exception e){
			//Set the invalidCommand object
			InvalidParser InvalidArgumentParser = new InvalidParser(MESSAGE_INVALID_ID);
			InvalidCommand = InvalidArgumentParser.executeCommand();
		}
	}
	
	private boolean isNullInvalidCommand() {
		return InvalidCommand == null;
	}
}
```
###### src\parser\DeleteParserTest.java
``` java
 *
 */

public class DeleteParserTest {

	POMPOM pompom = new POMPOM();
	TestSystem test = new TestSystem();
	PrettyTimeParser timeParser = pompom.timeParser;
	
	@Test
	public void testDelete() {
		//Initialize and fill up tasklist
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		AddParser addParser = new AddParser("do cs2103",false);
		addParser.parse().execute();
	
		//Run deleteParser and make sure the tasklist becomes empty.
		Long itemId = taskList.get(0).getId();
		DeleteParser deleteParser = new DeleteParser(itemId.toString());
		deleteParser.parse().execute();
		assertEquals(taskList.size(), 0);
	}
	
	@Test
	public void testNonExistentId() {
		//Initialize and fill up tasklist
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		AddParser addParser = new AddParser("do cs2103",false);
		addParser.parse().execute();
	
		//Run deleteParser and make sure nothing is deleted and the
		//correct error message is returned.
		Long invalidItemId = taskList.get(0).getId()+1;
		DeleteParser deleteParser = new DeleteParser(invalidItemId.toString());
		String errorMsg = deleteParser.parse().execute();
		assertEquals(taskList.size(), 1);
		assertEquals(errorMsg, String.format(DelCommand.MESSAGE_ID_INVALID,invalidItemId));
	}
	
	@Test
	public void testNullId() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		AddParser addParser = new AddParser("do cs2103",false);
		addParser.parse().execute();
	
		//Run deleteParser and make sure nothing is deleted and the
		//correct error message is returned.		
		DeleteParser deleteParser = new DeleteParser(null);
		String errorMsg = deleteParser.parse().execute();
		assertEquals(taskList.size(), 1);
		assertEquals(errorMsg, String.format(DeleteParser.MESSAGE_INVALID_ID,""));
	}
}
```
###### src\parser\DoneParser.java
``` java
 *
 */

public class DoneParser extends ArgsParser{
	
	public static final String INVALID_DONE_ARGUMENT_RETURN_MESSAGE = "%s: Is not a valid ID Number";
	private static final String LOG_CREATE_DONE_PARSER = "DoneParser Created for \"%s\"";

	private long itemID;
	private Command invalidCommand = null; 
	
	public DoneParser(String userCommand){
		super(userCommand);
		assertNotNull(commandArgumentsString);
		getItemId();
		logger.log(Level.INFO, String.format(LOG_CREATE_DONE_PARSER ,
											commandArgumentsString));
	}
	
	/**
	 * This method will return the appropriate Command to be processed
	 * by the Command class.
	 * 
	 * @return DelCommand() if the ID is an integer. InvalidCommand if it is not.
	 */
	public Command parse(){
		if (isNullInvalidCommand()){
			return new EditCommand(itemID, "status", POMPOM.STATUS_COMPLETED);
		} else{
			return invalidCommand;
		}
		
	}

	/**
	 * This method attempts to see if the ID is a valid integer or not. If it is,
	 * the itemID field is set. Else, the invalidCommand field will be set.
	 */
	public void getItemId(){
		try{
			itemID = Long.parseLong(commandArgumentsString);
		} catch (Exception e){
			String returnMsg = String.format(INVALID_DONE_ARGUMENT_RETURN_MESSAGE, commandArgumentsString);
			InvalidParser InvalidArgumentParser = new InvalidParser(returnMsg);
			invalidCommand = InvalidArgumentParser.executeCommand();
		}
	}
	
	private boolean isNullInvalidCommand() {
		return invalidCommand == null;
	}
}
```
###### src\parser\DoneParserTest.java
``` java
 *
 */
public class DoneParserTest {

	POMPOM pompom = new POMPOM();
	TestSystem test = new TestSystem();
	PrettyTimeParser timeParser = pompom.timeParser;
	
	@Test
	public void testDelete() {
		//Initialize and fill up tasklist
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		AddParser addParser = new AddParser("do cs2103",false);
		addParser.parse().execute();
	
		//Run deleteParser and make sure the tasklist becomes empty.
		Long itemId = taskList.get(0).getId();
		DoneParser doneParser = new DoneParser(itemId.toString());
		assertEquals(taskList.get(0).getStatus(), pompom.STATUS_FLOATING);
	}
	
	@Test
	public void testNonExistentId() {
		//Initialize and fill up tasklist
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		AddParser addParser = new AddParser("do cs2103",false);
		addParser.parse().execute();
	
		//Run deleteParser and make sure nothing is deleted and the
		//correct error message is returned.
		Long invalidItemId = taskList.get(0).getId()+1;
		DoneParser doneParser = new DoneParser(invalidItemId.toString());
		String errorMsg = doneParser.parse().execute();
		assertEquals(taskList.get(0).getStatus(), pompom.STATUS_FLOATING);
		assertEquals(errorMsg, String.format(DelCommand.MESSAGE_ID_INVALID,invalidItemId));
	}
	
	@Test
	public void testNullId() {
		//Initialize
		ArrayList<Item> taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
		AddParser addParser = new AddParser("do cs2103",false);
		addParser.parse().execute();
	
		//Run deleteParser and make sure nothing is deleted and the
		//correct error message is returned.		
		DoneParser doneParser = new DoneParser(null);
		String errorMsg = doneParser.parse().execute();
		assertEquals(taskList.get(0).getStatus(), pompom.STATUS_FLOATING);
		assertEquals(errorMsg, String.format(
						DoneParser.INVALID_DONE_ARGUMENT_RETURN_MESSAGE,""));
	}

}
```
###### src\parser\EditParser.java
``` java
 *
 */
public class EditParser extends ArgsParser{
	
	private static final int INDEX_REST_OF_THE_STRING = 1;
	private static final int INDEX_TASK_ID = 0;
	private static final String MESSAGE_NO_ARGUMENTS = "No Arguments";
	private static final String MESSAGE_PROPER_PRIORITY = "Priority only can be set to high/hi/h, medium/med/m or low/lo/l!";
	private static final String MESSAGE_INVALID_DATE_ERROR = "Please enter a vaild date";
	private static final String MESSAGE_INVALID_ARGUMENT_ERROR = "Please enter a vaild argument";
	public static final String MESSAGE_ID_ERROR = "Id must be a number";
	public static final String MESSAGE_TITLE_EMPTY_ERROR = "Title cannot be empty!";
	public static final String MESSAGE_FIELD_ERROR = "There is no such field!";
	private static final String STRING_EMPTY = "";
	private static final int VALID_NUMBER_OF_ARGUMENTS = 2;
	private static final String STRING_SPACE = " ";
	private static final String FIELD_PRIORITY = "priority";
	private static final String FIELD_TITLE = "title";	
	private static final String FIELD_LABEL = "label";
	private static final String FIELD_START_DATE = "start date";
	private static final String FIELD_END_DATE = "end date";
	
	private static final String LOG_CREATE_EDIT_PARSER = "EditParser Created for \"%s\"";

	private static final String[] FIELD_ARRAY = {FIELD_PRIORITY, FIELD_TITLE, 
												 FIELD_LABEL, 
												 FIELD_START_DATE, FIELD_END_DATE};
	
	private long taskID;
	private String field;
	private String newData;
	private String dataErrorMsg;
	private boolean correctId;
	private boolean correctField;
	private boolean correctData;
	private Date newDate = null;
	
	public EditParser(String userCommand){
		super(userCommand);
		assertNotNull(commandArgumentsString);
		correctId = extractTaskID();
		correctField = extractFields();
		correctData = extractNewData();
		
		logger.log(Level.INFO, String.format(LOG_CREATE_EDIT_PARSER ,
												commandArgumentsString));
	}
	
	public Command parse(){
		
		Command invalidCommand = validateFields();
		if (hasInvalidCommand(invalidCommand)){
			return invalidCommand;
		}
		
		//editing date field
		if (isNotEmptyDate()){
			return new EditCommand(taskID, field, newDate); 
		} else{
			return new EditCommand(taskID, field, newData);
		}
	}
 
	/**
	 * This method gets the ask ID from the command the user has entered.
	 * 
	 * @return
	 * 		true if task ID was sucessfully set. False if not.
	 */			
	public boolean extractTaskID(){
		
		//no arguments was given!
		if(hasNoArguments){
			return false;
		}
		
		//Splits the argument into 2. One part has the task ID. The other has the rest.
		String[] arguments = commandArgumentsString.split(STRING_SPACE,VALID_NUMBER_OF_ARGUMENTS);
		if (isInvalidArgumentsLength(arguments)){
			return false;
		}
		String taskIDString = arguments[INDEX_TASK_ID];				
		commandArgumentsString = arguments[INDEX_REST_OF_THE_STRING];
		
		return canSetTaskID(taskIDString);
	}
	
	/**
	 * This method extracts all the fields inside the command passed by the user.
	 * 
	 * @return
	 */
	public boolean extractFields(){
		if(isInvalidFields()){
			return false;
		}
		for (String currField: FIELD_ARRAY){
			//match currFied (the one inside the field array with the first available field.
			if (isFirstField(currField)){
				field=currField;
				commandArgumentsString = commandArgumentsString.substring(field.length()).trim();
				return true;
			}
		}
		//no fields are matched! means all the fields not valid.
		return false;
	}
	
	/**
	 * This method extracts the data related to the field. Also does validation.
	 * 
	 * @return
	 * 		the appropriate data object for the field
	 */
	public boolean extractNewData(){
		newData = commandArgumentsString;
		if (isNullField()){
			dataErrorMsg = MESSAGE_INVALID_ARGUMENT_ERROR;
			return false;
		}
		
		if (isEmptyTitleField()){
			dataErrorMsg = MESSAGE_TITLE_EMPTY_ERROR;
			return false;
		}
		
		//Process Date
		if (isValidDateField() ){
			return processDateField();
		}
		
		//Process Priority
		if(isProcessingPriorityField()){
			if (field != null) {
				return processPriorityField();
			} 
			else {
				dataErrorMsg = MESSAGE_PROPER_PRIORITY;
				return false;
			}
		}
		if(hasNoArguments){
			dataErrorMsg = MESSAGE_NO_ARGUMENTS;
			return false;
		}
		return true;
	}

	private boolean isProcessingPriorityField() {
		return field == FIELD_PRIORITY;
	}

	private boolean isEmptyTitleField() {
		return field.equals("title") && newData.equals("");
	}

	private boolean isNullField() {
		return field == null;
	}
	/**
	 * This method checks if the data is a valid priority data, then returns
	 * the appropriate priority data than can be used by the command.
	 * 
	 * @return 
	 * 		true if priority is sucessfully set. false if it is not.
	 */
	private boolean processPriorityField() {
		if (isValidHighPriorityCommand(newData)) {
			newData = POMPOM.PRIORITY_HIGH;
			return true;
		} else if (isValidMediumPriorityCommand(newData)){
			newData = POMPOM.PRIORITY_MED;
			return true;
		} else if (isValidLowPriorityCommand(newData)){
			newData = POMPOM.PRIORITY_LOW;
			return true;
		} else {
			dataErrorMsg = MESSAGE_PROPER_PRIORITY;
			return false;
		}
	}
	
	/**
	 * This method checks if the data is a valid date data, then returns
	 * the appropriate date data than can be used by the command.
	 * 
	 * @return 
	 * 		true if priority is sucessfully set. false if it is not.
	 */
	private boolean processDateField() {
		newDate = getDate(newData); 
		if(isNotEmptyDate()){
			return true;
		}else{
			dataErrorMsg = MESSAGE_INVALID_DATE_ERROR;
			return false;
		}
	}
	
	/**
	 * This method attempts to see if the ID is a valid long or not. If it is,
	 * the TaskID field is set. Else, the invalidCommand field will be set.
	 * 
	 * @return 
	 * 		true if can successfully set Task ID. False if cannot.
	 */
	private boolean canSetTaskID(String taskIDString) {
		try{
			taskID = Long.parseLong(taskIDString);
		} catch (Exception e){
			return false;
		}
		return true;
	}
	
	/**
	 * This method checks for all error flags. If any of them is raised, 
	 * an invalidCommand is returned. 
	 * @return
	 * 		invalidCommand with error msg if got raised error flags. false if dont have.
	 */
	private Command validateFields() {
		if(!correctId){
			return new InvalidCommand(MESSAGE_ID_ERROR);
		} else if(!correctField){
			return new InvalidCommand(String.format(MESSAGE_FIELD_ERROR));
		} else if(!correctData){
			return new InvalidCommand(dataErrorMsg);
		} else{
			return null;
		}
	}

	private Date getDate(String data) {
		return POMPOM.timeParser.parseSyntax(data).get(0).getDates().get(0);
	}
	
	public String getField(){
		return field;
	}
	
	public String getNewData(){
		return newData;
	}
	
	private boolean isInvalidArgumentsLength(String[] arguments) {
		return arguments.length < VALID_NUMBER_OF_ARGUMENTS;
	}
	
	private boolean isFirstField(String currField) {
		return commandArgumentsString.indexOf(currField) == 0;
	}

	private boolean isInvalidFields() {
		return commandArgumentsString == null || commandArgumentsString.equals(STRING_EMPTY);
	}
	
	private boolean isValidHighPriorityCommand(String priority){
		//Appropriate commands are: "high", "hi", "h"
		return priority.equalsIgnoreCase(AddParser.PRIORITY_HIGH_CMD1) 
				|| priority.equalsIgnoreCase(AddParser.PRIORITY_HIGH_CMD2) 
				|| priority.equalsIgnoreCase(AddParser.PRIORITY_HIGH_CMD3);
	}
	
	private boolean isValidMediumPriorityCommand(String priority){
		//Appropriate commands are: "medium", "med", "m"
		return priority.equalsIgnoreCase(AddParser.PRIORITY_MEDIUM_CMD1) 
				|| priority.equalsIgnoreCase(AddParser.PRIORITY_MEDIUM_CMD2) 
				|| priority.equalsIgnoreCase(AddParser.PRIORITY_MEDIUM_CMD3);
	}
	
	private boolean isValidLowPriorityCommand(String priority){
		//Appropriate commands are: "low", "lo", "l"
		return priority.equalsIgnoreCase(AddParser.PRIORITY_LOW_CMD1) 
				|| priority.equalsIgnoreCase(AddParser.PRIORITY_LOW_CMD2) 
				|| priority.equalsIgnoreCase(AddParser.PRIORITY_LOW_CMD3);
	}
	
	private boolean hasInvalidCommand(Command invalidCommand) {
		return invalidCommand!=null;
	}
	
	private boolean isNotEmptyDate() {
		return newDate != null;
	}

	private boolean isValidDateField() {
		return field.equals(FIELD_START_DATE) || field.equals(FIELD_END_DATE);
	}
	
}
```
###### src\parser\EditParserTest.java
``` java
 *
 */
public class EditParserTest {

	@Test
	public void testGetFields() {
		EditParser editParser = new EditParser("1 title new title");
		assertEquals(editParser.getField(),"title");
	}
	
	/*
	 * New data field has the name of the title inside.
	 */
	@Test
	public void testGetNewData() {
		EditParser editParser = new EditParser("1 title new title");
		assertEquals(editParser.getNewData(),"new title");
	}
	

}
```
###### src\parser\EditRecurringParser.java
``` java
 *
 */
public class EditRecurringParser extends ArgsParser{
	 
	
	private static final String FIELD_PRIORITY = "priority";
	private static final String FIELD_TITLE = "title";	
	private static final String FIELD_LABEL = "label";
	private static final String FIELD_START_DATE = "start date";
	private static final String FIELD_END_DATE = "end date";

	private static final String[] FIELD_ARRAY = {FIELD_PRIORITY, FIELD_TITLE, 
												 FIELD_LABEL, 
												 FIELD_START_DATE, FIELD_END_DATE};
	
	private Long taskID;
	private String field;
	private String newData;
	private Date newDate = null;
	public static final String ID_ERROR_MESSAGE = "Id must be a number!";
	public static final String FIELD_ERROR_MESSAGE = "There is no such field!";
	private static final String LOG_CREATE_EDIT_RECURRING_PARSER = "EditRecuringParser Created for \"%s\"";
	
	boolean correctId;
	boolean correctField;
	boolean correctData;
	String dataErrorMsg;
	
	
	public EditRecurringParser(String userCommand){
		super(userCommand);
		assertNotNull(commandArgumentsString);
		commandArgumentsString = commandArgumentsString.trim();
		correctId = extractTaskID();
		correctField = extractFields();
		correctData = extractNewData();
		logger.log(Level.INFO, String.format(LOG_CREATE_EDIT_RECURRING_PARSER, commandArgumentsString));
	}
	
	public Command parse(){
		if(!correctId){
			return new InvalidCommand(ID_ERROR_MESSAGE);
		}
		if(!correctField){
			return new InvalidCommand(String.format(FIELD_ERROR_MESSAGE));
		}
		if(!correctData){
			return new InvalidCommand(dataErrorMsg);
		}
		else{
			return new EditRecurringCommand(taskID, field, newData);
		}
	}
 
//	private boolean isEditingDateField() {
	//	return (newDate!=null);
	//}
	
	public boolean extractTaskID(){
		if(hasNoArguments){
			return false;
		}
		String[] arguments = commandArgumentsString.split(" ",2);
		if (arguments.length == 0||arguments.length == 1 ){
			return false;
		}
		String taskIDString = arguments[0];				
		commandArgumentsString = arguments[1];
		
		try{
			taskID = Long.parseLong(taskIDString);
			
		} catch (Exception e){
			
		}
		if(taskID == null){
			return false;
		}
		else{
			return true;
		}
	}
	
	public boolean extractFields(){
		if(commandArgumentsString == null || commandArgumentsString.equals("")){
			return false;
		}
		for (String currField: FIELD_ARRAY){
			if (commandArgumentsString.indexOf(currField) == 0){
				field=currField;
				commandArgumentsString = commandArgumentsString.replace(field, "").trim();
				return true;
			}
		}
		return false;
	}
	
	public boolean extractNewData(){
		newData = commandArgumentsString;
		if(field == null){
			dataErrorMsg = "Please enter a vaild argument";
			return false;
		}
		if (field.equals("start date") || field.equals("end date") ){
			newDate = getDate(newData); 
			if(newDate != null){
				
				return true;
			}else{
				dataErrorMsg = "Please enter a vaild date";
				return false;
			}
			
		}		
		if(field == FIELD_PRIORITY){
			if (field != null) {
				if (newData.equalsIgnoreCase("h") || newData.equalsIgnoreCase("high")) {
					newData = POMPOM.PRIORITY_HIGH;
					return true;
				} else if (newData.equalsIgnoreCase("m") || newData.equalsIgnoreCase("med")
						|| newData.equalsIgnoreCase("med")) {
					newData = POMPOM.PRIORITY_MED;
					return true;
				} else if (newData.equalsIgnoreCase("l") || newData.equalsIgnoreCase("low")) {
					newData = POMPOM.PRIORITY_LOW;
					return true;
				} else {
					dataErrorMsg = "Priority only can be set to high medium low!";
					return false; 
				}
			} 
			else {
				dataErrorMsg = "Priority only can be set to high medium low!";
				return false;
			}
		}
		if(hasNoArguments){
			dataErrorMsg = "No Arguments";
			return false;
		}
		return true;
	}

	private Date getDate(String data) {
		return POMPOM.timeParser.parseSyntax(data).get(0).getDates().get(0);
	}
	
	public String getField(){
		return field;
	}
	
	public String getNewData(){
		return newData;
	}
	
}
```
###### src\parser\ExitParser.java
``` java
 *
 */
public class ExitParser{
	
	protected static Logger logger = Logger.getLogger("Parser");
	private static final String LOG_CREATE_EXIT_PARSER = "ExitParser Created";
	
	public Command parse(){
		logger.log(Level.INFO, LOG_CREATE_EXIT_PARSER);
		return new ExitCommand();
	}
}
```
###### src\parser\HelpParser.java
``` java
 *
 */
public class HelpParser{
	
	protected static Logger logger = Logger.getLogger("Parser");
	private static final String LOG_CREATE_HELP_PARSER = "HelpParser Created";
	
	public HelpParser(){
		logger.log(Level.INFO, LOG_CREATE_HELP_PARSER);
	}
	
	public Command parse(){
		return new HelpCommand(); 
	}
}
```
###### src\parser\InvalidParser.java
``` java
 *
 */
public class InvalidParser {
	
	private String invalidCommand;
	protected static Logger logger = Logger.getLogger("Parser");
	private static final String LOG_CREATE_INVALID_PARSER = "InvalidParser Created";
	
	public InvalidParser(String userCommand){
		invalidCommand = userCommand; 	
		assertNotNull(userCommand);
		logger.log(Level.INFO, LOG_CREATE_INVALID_PARSER);
	}
	
	public Command executeCommand(){
		return new InvalidCommand(invalidCommand);
	}
}
```
###### src\parser\Parser.java
``` java
 *
 */
public class Parser {

	/** List of Command types */
	private static final String CMD_ADD = "add";
	private static final String CMD_DELETE = "delete";
	private static final String CMD_DONE = "done";
	private static final String CMD_EDIT = "edit";
	private static final String CMD_EXIT = "exit";
	private static final String CMD_SEARCH = "search";
	private static final String CMD_SHOW = "show";
	private static final String CMD_UNDO = "undo";
	private static final String CMD_PATH = "setpath";
	private static final String CMD_EVENT = "event";
	private static final String CMD_HELP_1 = "help";
	private static final String CMD_TITLE = "title";
	private static final String CMD_HELP_2 = "?";
	private static final String CMD_DELETE_RECUR_1 = "delete r";
	private static final String CMD_EDIT_RECUR_1 = "edit r";
	private static final String CMD_DELETE_RECUR_2 = "deleterecur";
	private static final String CMD_EDIT_RECUR_2 = "editrecur";
	private static final String CMD_VIEW = "view";

	/** List of Invalid command types */
	public static final String INVALID_CMD_MESSAGE = "%s: Command does not exist";

	// private static final int COMMAND_ARRAY_SIZE = 2;
	// private static final int COMMAND_TYPE_INDEX = 0;
	// private static final int COMMAND_ARGUMENT_INDEX = 1;

	private static Parser parserInstance;

	private static Logger logger = Logger.getLogger("Parser");

	public static Parser getInstance() {
		if (parserInstance == null)
			parserInstance = new Parser();

		return parserInstance;
	}

	private Parser() {

	}

	/**
	 * This operation takes in the command specified by the user, executes it
	 * and returns a message about the execution information to the user.
	 * 
	 * @param userCommand
	 *            is the command the user has given to the program
	 * @return the message containing information about the execution of the
	 *         command.
	 */
	public Command parse(String userCommand) {

		String commandType = getStringCommand(userCommand);
		String commandArgument = getStringArgs(userCommand);

		
		// Recur commands must be on top.
		switch (commandType) {
		
		case CMD_EDIT_RECUR_1:
		case CMD_EDIT_RECUR_2:
			EditRecurringParser EditRecurringArgumentParser = new EditRecurringParser(commandArgument);
			return EditRecurringArgumentParser.parse();
		case CMD_DELETE_RECUR_1:
		case CMD_DELETE_RECUR_2:
			DeleteRecurringParser DeleteRecurringParser = new DeleteRecurringParser(commandArgument);
			return DeleteRecurringParser.parse();
		case CMD_ADD:
			AddParser addTaskArgumentParser = new AddParser(commandArgument,false);
			return addTaskArgumentParser.parse();
		case CMD_EVENT:
			AddParser addEventArgumentParser = new AddParser(commandArgument,true);
			return addEventArgumentParser.parse();
		case CMD_DELETE:
			DeleteParser deleteArgumentParser = new DeleteParser(commandArgument);
			return deleteArgumentParser.parse();
		case CMD_EDIT:
			EditParser EditArgumentParser = new EditParser(commandArgument);
			return EditArgumentParser.parse();
		case CMD_SEARCH:
			SearchParser searchParser = new SearchParser(commandArgument);
			return searchParser.parse();
		case CMD_EXIT:
			ExitParser exitParser = new ExitParser();
			return exitParser.parse();
		case CMD_UNDO:
			UndoParser undoParser = new UndoParser();
			return undoParser.parse();
		case CMD_HELP_1:
		case CMD_HELP_2:
			HelpParser helpParser = new HelpParser();
			return helpParser.parse();
		case CMD_PATH:
			return new PathCommand(commandArgument); 
		case CMD_VIEW:
			ViewParser viewParser = new ViewParser(commandArgument);
			return viewParser.parse();
		case CMD_DONE:
			DoneParser DoneArgumentParser = new DoneParser(commandArgument);
			return DoneArgumentParser.parse();
		case CMD_TITLE:
			TitleParser titleParser = new TitleParser(commandArgument);
			return titleParser.parse();
		default:
			String returnMsg = String.format(INVALID_CMD_MESSAGE, commandType);
			InvalidCommand invalidCommand = new InvalidCommand(returnMsg);
			return invalidCommand;
		}

	}

	private static String getStringCommand(String userInput) {
		String[] toSplit = userInput.split(" ", 2);
		return toSplit[0].toLowerCase().trim();
	}

	private static String getStringArgs(String userInput) {
		String[] toSplit = userInput.split(" ", 2);
		if (toSplit.length > 1) {
			return toSplit[1].trim();
		} else {
			return null;
		}
	}

}
```
###### src\parser\ParserTest.java
``` java
 *
 */
public class ParserTest {
	POMPOM pompom = new POMPOM();
	Parser parser = Parser.getInstance();
	
	/*
	 * This is the boundary case for the valid user commands partition
	 */
	@Test
	public void testAddCommand() {
		Command outputCommand = parser.parse("add do cs2013");
		assertTrue(outputCommand instanceof command.AddCommand);
	}
	
	/*
	 * This is the boundary case for the invalid user commands partition
	 */
	@Test
	public void testFailCommand() {
		Command outputCommand = parser.parse("ad do cs2013");
		assertTrue(outputCommand instanceof command.InvalidCommand);
	}
	
	/*
	 * This is the boundary case for the invalid user commands partition
	 */
	@Test
	public void testRecurringCommands() {
		Command outputCommand = parser.parse("delere recur do cs2013");
		assertTrue(outputCommand instanceof command.InvalidCommand);
	}
	


}
```
###### src\parser\PathParser.java
``` java
 *
 */
public class PathParser extends ArgsParser{
	
	private String path;
	private static final String LOG_CREATE_PATH_PARSER = "PathParser Created for \"%s\"";;
	
	public PathParser(String userCommand){
		super(userCommand);
		assertNotNull(commandArgumentsString);
		this.path = commandArgumentsString;
		logger.log(Level.INFO, String.format(LOG_CREATE_PATH_PARSER ,
					commandArgumentsString));
	}
	
	public Command parse(){
		return new UndoCommand();	
	}
	
}
```
###### src\parser\SearchParser.java
``` java
 */
public class SearchParser extends ArgsParser{
	
	private static final String STRING_EMPTY = "";
	private static final String MESSAGE_NO_ARGUMENTS_ERROR = "Search must have arguments";
	private static final String LOG_CREATE_SEARCH_PARSER = "SearchParser Created for \"%s\"";;
	private String keyWord;
	
	public SearchParser(String commandArguments) {
		super(commandArguments);
		assertNotNull(commandArgumentsString);
		keyWord = commandArguments;
		logger.log(Level.INFO, String.format(LOG_CREATE_SEARCH_PARSER ,
				commandArgumentsString));
		
	}
	
	public Command parse(){
			if(isInvalidKeyword()){
				return new InvalidCommand(MESSAGE_NO_ARGUMENTS_ERROR);
			}
			return new SearchCommand(keyWord);
	}
	
	private boolean isInvalidKeyword() {
		return keyWord == null || keyWord.equals(STRING_EMPTY);
	}

}
```
###### src\parser\TitleParser.java
``` java
 *
 */
public class TitleParser extends ArgsParser{
	Long id;
	public TitleParser(String commandArguments){
		super(commandArguments);
		
		
	}
	public Command parse(){
		try{
			id = Long.parseLong(this.commandArgumentsString);
		}catch (Exception e){
			return new InvalidCommand(DelCommand.MESSAGE_ID_INVALID);
		}
		return new TitleCommand(id);
	}
}
```
###### src\parser\UndoParser.java
``` java
 *
 */

public class UndoParser {	
	
	protected static Logger logger = Logger.getLogger("Parser");
	private static final String LOG_CREATE_UNDO_PARSER = "UndoParser Created";
	
	public UndoParser(){
		logger.log(Level.INFO, LOG_CREATE_UNDO_PARSER);
	}
	
	public Command parse(){
		return new UndoCommand();
	}
}
```
###### src\parser\ViewParser.java
``` java
 *
 */
public class ViewParser extends ArgsParser{
	
	private String view;
	private static final String LOG_CREATE_VIEW_PARSER = "DeleteParser Created for \"%s\"";
	
	public ViewParser(String commandArgument) {
		super(commandArgument); 
		assertNotNull(commandArgumentsString);
		view = commandArgument;
		logger.log(Level.INFO, String.format(LOG_CREATE_VIEW_PARSER ,
				commandArgumentsString));
	}
	
	public Command parse(){
			return new ViewCommand(view);
	}
}
```
