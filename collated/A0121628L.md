# A0121628L
###### src\gui\MainController.java
``` java
	 * @param event
	 */
	@FXML
	public void changeToHighPriority(ActionEvent event) {

		highLightLabel(highPriorityLbl);
		// Filter the list and configure the table
		filterList("high");

	}

	/**
	 * Action that changes the display content list to medium priority items
	 * 
```
###### src\gui\MainController.java
``` java
	 * @param event
	 */
	@FXML
	public void changeToMediumPriority(ActionEvent event) {
		highLightLabel(mediumPriorityLbl);
		// Filter the list and configure the table
		filterList("medium");
	}

	/**
	 * Action that changes the display content list to low priority items
	 * 
```
###### src\gui\MainController.java
``` java
	 * @param event
	 */
	@FXML
	public void changeToLowPriority(ActionEvent event) {
		highLightLabel(lowPriorityLbl);
		// Filter the list and configure the table
		filterList("low");
	}

	/**
	 * The method selects the specified
	 * 
```
###### src\gui\MainController.java
``` java
	 * @param inputTab
	 *            // Name of input tab
	 */
	public void switchToTab(String inputTab) {
		String tabName = inputTab.toLowerCase();
		SingleSelectionModel<Tab> selectionModel = tabViews.getSelectionModel();

		if (tabName.equals(POMPOM.LABEL_TASK.toLowerCase())) {
			selectionModel.select(taskTab);
			taskTabAction();
		} else if (tabName.equals(POMPOM.LABEL_COMPLETED_TASK.toLowerCase())) {
			selectionModel.select(completedTaskTab);
			completedTaskTabAction();
		} else if (tabName.equals(POMPOM.LABEL_EVENT.toLowerCase())) {
			selectionModel.select(eventTab);
			eventTabAction();
		} else if (tabName.equals(POMPOM.LABEL_COMPLETED_EVENT.toLowerCase())) {
			selectionModel.select(completedEventTab);
			completedEventTabAction();
		} else if (tabName.equals(POMPOM.LABEL_SEARCH.toLowerCase())) {
			selectionModel.select(searchTab);
			searchTabAction();
		}
	}

	/**
	 * Update Gui tabview and Displaylist view on this action
	 * 
```
###### src\gui\MainController.java
``` java
	 * 
	 */
	@FXML
	public void taskTabAction() {
		if (!initialized)
			return;
		GUIModel.update();
		displayList = GUIModel.getTaskList();
		configureTable();
		POMPOM.setCurrentTab(POMPOM.LABEL_TASK);
	}

	/**
	 * Update Gui tabview and Displaylist view on this action
	 * 
```
###### src\gui\MainController.java
``` java
	 * 
	 */
	@FXML
	public void completedTaskTabAction() {
		GUIModel.update();
		displayList = GUIModel.getTaskDoneList();
		configureTable();
		POMPOM.setCurrentTab(POMPOM.LABEL_COMPLETED_TASK);
	}

	/**
	 * Update Gui tabview and Displaylist view on this action
	 * 
```
###### src\gui\MainController.java
``` java
	 */
	@FXML
	public void eventTabAction() {
		GUIModel.update();
		displayList = GUIModel.getEventList();
		configureTable();
		POMPOM.setCurrentTab(POMPOM.LABEL_EVENT);
	}

	/**
	 * Update Gui tabview and Displaylist view on this action
	 * 
```
###### src\gui\MainController.java
``` java
	 */
	@FXML
	public void completedEventTabAction() {
		GUIModel.update();
		displayList = GUIModel.getEventDoneList();
		configureTable();
		POMPOM.setCurrentTab(POMPOM.LABEL_COMPLETED_EVENT);
	}

	/**
	 * Update Gui tabview and Displaylist view on this action
	 * 
```
###### src\gui\MainController.java
``` java
	 */
	public void searchTabAction() {
		displayList = GUIModel.getSearchList();

		configureTable();
		POMPOM.setCurrentTab(POMPOM.LABEL_SEARCH);
	}

	/**
```
###### src\gui\MainController.java
``` java
	 * @param event
	 *            --Button clicked is the event
	 * @throws IOException
	 */
	public void enterCommandFired(ActionEvent event) throws IOException {
		// Clear input string
		String input = inputCommand.getText();
		inputCommand.clear();
		// Execute command
		String msg = pompom.execute(input);
		POMPOM.getStorage().saveStorage();
		// Update Gui
		lanuchHelp(POMPOM.showHelp);
		displayReturnMessage(msg);
		configureTable();
		setNotificationLabels();
		inputCommand.setPromptText("Command:");
		switchToTab(POMPOM.getCurrentTab().toLowerCase());
		selectRow(input);
	}

	/**
	 * Method to handle the enter key pressed in input command
	 * 
```
###### src\gui\MainController.java
``` java
	 * 
	 * @param event
	 * @throws IOException
	 */
	@FXML
	public void enterCommandKey(KeyEvent event) throws IOException {
		if (event.getCode().equals(KeyCode.ENTER)) {
			// clear input string
			String input = inputCommand.getText();
			// Execute command
			String msg = pompom.execute(input);
			POMPOM.getStorage().saveStorage();

			// Update GUI
			displayReturnMessage(msg);
			configureTable();
			setNotificationLabels();

			lanuchHelp(POMPOM.showHelp);
			inputCommand.clear();
			inputCommand.setPromptText("Command:");
			switchToTab(POMPOM.getCurrentTab().toLowerCase());
			selectRow(input);
		}

	}

	/*********************************** Helper methods **********************************/

	/**
	 * Method to configure the buttons functionality(Clickable a not at the
	 * start) Edit is not clickable cause it requires user to highlight item.
	 * 
```
###### src\gui\MainController.java
``` java
	 */
	private void configureButtons() {
		if (newTask != null) {
			newTask.setDisable(false);
		}
		if (editTask != null) {
			editTask.setDisable(true);
		}
		if (deleteTask != null) {
			deleteTask.setDisable(false);
		}
		if (enterCommand != null) {
			enterCommand.setDisable(false);
		}
	}

	/**
	 * Configure the table view with the latest and correct information
	 * 
```
###### src\gui\MainController.java
``` java
	 */
	void configureTable() {
		// To tick checkbox
		table.setEditable(true);
		taskID.setCellValueFactory(new PropertyValueFactory<Item, Number>("id"));
		taskName.setCellValueFactory(new PropertyValueFactory<Item, String>(
				"title"));

		// Checkbox init
		checkBox.setGraphic(selectAll);
		checkBox.setCellFactory(CheckBoxTableCell.forTableColumn(checkBox));
		checkBox.setCellValueFactory(c -> c.getValue().checkedProperty());

		taskStartDateTime
				.setCellValueFactory(new PropertyValueFactory<Item, String>(
						"sd"));

		taskEndDateTime
				.setCellValueFactory(new PropertyValueFactory<Item, String>(
						"ed"));
		taskLabel.setCellValueFactory(new PropertyValueFactory<Item, String>(
				"label"));
		taskPriority
				.setCellValueFactory(new PropertyValueFactory<Item, String>(
						"priority"));
		taskStatus.setCellValueFactory(new PropertyValueFactory<Item, String>(
				"status"));

		GUIModel.update();

		selectAllCheckBox(selectAll);
		// Populate data

		table.setItems(displayList);
		table.refresh();

	}

	/**
	 * Highlight the item which has just been added or modified
	 * 
```
###### src\gui\MainController.java
``` java
	 */
	public void selectAllCheckBox(CheckBox cb) {
		cb.selectedProperty().addListener(new ChangeListener<Boolean>() {
			public void changed(ObservableValue<? extends Boolean> ov,
					Boolean old_val, Boolean new_val) {

				int rows = table.getItems().size();
				for (int i = 0; i < rows; i++) {
					boolean preVal = displayList.get(i).getChecked();

					displayList.get(i).setChecked(!preVal);

				}
			}
		});
	}

	/**
```
###### src\gui\MainController.java
``` java
	 * @param color
	 */
	private void setBackgroundColor(String color) {
		BackgroundFill myBF = new BackgroundFill(Color.valueOf(color),
				CornerRadii.EMPTY, Insets.EMPTY);
		content.setBackground(new Background(myBF));
	}

	/**
	 * Set the notification numbers in the labels Eg. Number of task today
	 * 
```
###### src\gui\MainController.java
``` java
	 */
	public void setNotificationLabels() {
		GUIModel.update();
		taskNo.setText(ListClassifier.getTodayTask(POMPOM.getStorage()
				.getTaskList()));
		overdueNo.setText(ListClassifier.getOverdueTask(POMPOM.getStorage()
				.getTaskList()));
		eventsNo.setText(ListClassifier.getTodayEvent(POMPOM.getStorage()
				.getTaskList()));
	}

	/**
	 * Displays Notification Message
	 * 
```
###### src\gui\MainController.java
``` java
	 */
	public void displayReturnMessage(String message) {
		Timeline timeline = new Timeline();
		timeline.getKeyFrames().add(
				new KeyFrame(Duration.seconds(0), new KeyValue(returnMsg
						.textProperty(), message)));
		timeline.getKeyFrames().add(
				new KeyFrame(Duration.seconds(4), new KeyValue(returnMsg
						.textProperty(), " ")));
		timeline.play();
	}

	/**
	 * HighLight the clicked label
	 * 
```
###### src\gui\MainController.java
``` java
	 * @param label
	 */
	public void highLightLabel(Label label) {
		dashboardLbl.setTextFill(Color.web(DEFAULT_LABEL_COLOR));
		settingLbl.setTextFill(Color.web(DEFAULT_LABEL_COLOR));
		highPriorityLbl.setTextFill(Color.web(DEFAULT_LABEL_COLOR));
		mediumPriorityLbl.setTextFill(Color.web(DEFAULT_LABEL_COLOR));
		lowPriorityLbl.setTextFill(Color.web(DEFAULT_LABEL_COLOR));

		label.setTextFill(Color.web(DEFAULT_HIGHLIGHT_COLOR));
	}

	/**
	 * Set the colours gotten from the settings text file
	 * 
```
###### src\gui\MainController.java
``` java
	 */
	public void setSettingsColours() {
		Settings setting = GUIModel.getSettings();
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				setBackgroundColor(setting.getBackgroundColour());
				returnMsg.setStyle(CSS_STYLE_TEXT
						+ setting.getReturnMsgColour());
				inputCommand.setStyle(CSS_STYLE_TEXT
						+ setting.getInputTxtColour());

			}
		});
	}

	/**
	 * As method name.
	 * 
```
###### src\gui\MainController.java
``` java
	 */
	private void initializeSceneShortcuts() {
		Scene scene = mainPane.getScene();
		scene.setOnKeyPressed(shortcutHandler);
		inputCommand.addEventHandler(KeyEvent.KEY_PRESSED, inputFieldShortcut);
		table.addEventHandler(KeyEvent.KEY_PRESSED, tableShortcut);

	}

	/**
	 * Common shortcut command that shares across all items in the view
	 * 
```
###### src\gui\MainController.java
``` java
	 * @param ke
	 *            Keyevent
	 * 
	 */
	public void commonShortCut(KeyEvent ke) {
		if (UNDO_SHORTCUT.match(ke)) {
			String msg = pompom.execute(UNDO_COMMAND_STRING);
			switchToTab(POMPOM.getCurrentTab().toLowerCase());
			displayReturnMessage(msg);
			try {
				POMPOM.getStorage().saveStorage();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			configureTable();
		} else if (SWITCH_TAB_SHORTCUT.match(ke)) {
			hotkeySwitchTab();
		} else if (DELETE_SHORTCUT.match(ke)) {
			Item item = table.getSelectionModel().getSelectedItem();
			if (item != null) {
				pompom.execute("delete " + item.getId());
				configureTable();
				try {
					POMPOM.getStorage().saveStorage();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				switchToTab(GUIModel.getCurrentTab());
				return;
			}

		} else if (NO_FILTER_SHORTCUT.match(ke)) {
			switchToTab(GUIModel.getCurrentTab());
			highLightLabel(dashboardLbl);

		} else if (LOW_FILTER_SHORTCUT.match(ke)) {
			switchToTab(GUIModel.getCurrentTab());
			filterList("low");
			highLightLabel(lowPriorityLbl);
		} else if (MEDIUM_FILTER_SHORTCUT.match(ke)) {
			switchToTab(GUIModel.getCurrentTab());
			filterList("medium");
			highLightLabel(mediumPriorityLbl);
		} else if (HIGH_FILTER_SHORTCUT.match(ke)) {
			switchToTab(GUIModel.getCurrentTab());
			filterList("high");
			highLightLabel(highPriorityLbl);
		}
	}

	/**
	 * Hotkey to switch to next tab
	 *
```
###### src\gui\MainController.java
``` java
	 */
	public void hotkeySwitchTab() {

		if (GUIModel.getCurrentTab().equals(POMPOM.LABEL_TASK)) {
			switchToTab(POMPOM.LABEL_COMPLETED_TASK);
			GUIModel.setCurrentTab(POMPOM.LABEL_COMPLETED_TASK);
		} else if (GUIModel.getCurrentTab().equals(POMPOM.LABEL_COMPLETED_TASK)) {
			switchToTab(POMPOM.LABEL_EVENT);
			GUIModel.setCurrentTab(POMPOM.LABEL_EVENT);
		} else if (GUIModel.getCurrentTab().equals(POMPOM.LABEL_EVENT)) {
			switchToTab(POMPOM.LABEL_COMPLETED_EVENT);
			GUIModel.setCurrentTab(POMPOM.LABEL_COMPLETED_EVENT);

		} else if (GUIModel.getCurrentTab()
				.equals(POMPOM.LABEL_COMPLETED_EVENT)) {
			switchToTab(POMPOM.LABEL_SEARCH);
			GUIModel.setCurrentTab(POMPOM.LABEL_SEARCH);

		} else if (GUIModel.getCurrentTab().equals(POMPOM.LABEL_SEARCH)) {
			switchToTab(POMPOM.LABEL_TASK);
			GUIModel.setCurrentTab(POMPOM.LABEL_TASK);
		}
	}

	/**
	 * filter the list
	 * 
```
###### src\gui\MainController.java
``` java
	 * @param priority
	 */
	public void filterList(String priority) {
		GUIModel.update();
		// Filter
		switchToTab(GUIModel.getCurrentTab());
		displayList = ListClassifier.getSpecifiedPrirorirty(displayList,
				priority);
		configureTable();
	}

	/**
	 * Format the date to this format to be keyed into the table
	 * 
```
###### src\gui\MainController.java
``` java
	 * @param date
	 */
	public void formatDate(Date date) {
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd");
		Date d = new Date();
		dateFormat.format(d);

	}

	/**
	 * Check whether help dialog is required to launch a not
	 * 
```
###### src\gui\MainController.java
``` java
	 * @param launched
	 *            when true launch help
	 */
	public void lanuchHelp(boolean launched) {
		if (launched == true) {
			POMPOM.showHelp = false;
			main.helpDialog();
		} else {
			return;
		}
	}

}
```
###### src\storage\Storage.java
``` java
 * 
 */
public class Storage {

	private final static String DEFAULT_FILE_DIRECTORY = "PomPom Storage & Settings";
	private final static String DEFAULT_FILE_NAME = "Storage.txt";
	public final static String DEFAULT_STORAGE_FILE_PATH = DEFAULT_FILE_DIRECTORY
			+ "/" + DEFAULT_FILE_NAME;

	/** storageFile is not final as user can reset storage file path */
	private final File DEFAULT_DIRECTORY_FILE = new File(DEFAULT_FILE_DIRECTORY);
	private File storageFile = new File(DEFAULT_STORAGE_FILE_PATH);
	private String storageFilePath = DEFAULT_STORAGE_FILE_PATH;

	private final String SETTINGS_FILE_NAME = "settings.txt";
	private final String SETTINGS_FILE_PATH = DEFAULT_FILE_DIRECTORY + "/"
			+ SETTINGS_FILE_NAME;

	private final File settingsFile = new File(SETTINGS_FILE_PATH);
	private Settings settings;

	private final String ERROR_DIALOG_TITLE = "Error Dialog";
	private final String ERROR_DIALOG_HEADER = "Storage settings or file error";
	private final String FILE_READ_ERROR_MESSAGE = "ERROR READING %s FILE! SETTINGS FILE WAS MODIFIED ILLEGAL!"
			+ "PLEASE REMOVE ILLEGAL FILE OR MODIFY FILE. REMOVE/EDIT SETTINGS FILE TO RESET";
	private final String CREATE_FILE_DIRECTORY_ERROR_MESSAGE = "ERROR IN CREATING DIRERCTORY. "
			+ "FILE DIRECTORY ALREADY EXSITS. REMOVE/EDIT SETTINGS FILE TO RESET";
	private final String LIGHT_STORAGE_ERROR = "File is a directory. Storage path set to default";
	/** The main data that is being extracted to this objects */
	private UserItemList userItemList;
	private ArrayList<Item> taskList;
	private long idCounter;

	/** This library need to be initialized for the parser */
	public PrettyTimeParser timeParser;

	/** Gson Library objects to read settings and storage file in json format */
	final GsonBuilder GSON_ITEM_BUILDER = new GsonBuilder();
	final GsonBuilder GSON_SETTINGS_BUILDER = new GsonBuilder();
	private Gson gsonItem;
	private Gson gsonSettings;

	private Logger logger = Logger.getLogger("Storage");

	public Storage() throws IOException {

	}

	/**
	 * This method initializes the main objects of the storage which are the
	 * settings/storage.txt and Gson objects(JSON library).
	 * 
	 * @throws IOException
	 */
	public void init() throws IOException {
		initializeGsonObjects();
		initializeSettings();
		initializeStorage();
		logger.log(Level.INFO, "Initialized Storage");
		// Loading NLP library for parser for quick access
		timeParser = new PrettyTimeParser();
		timeParser.parseSyntax("next year");
	}

	/** Getters and Setters */
	public UserItemList getUserTaskList() {
		return userItemList;
	}

	public void setUserTaskList(UserItemList userTaskList) {
		this.userItemList = userTaskList;
	}

	public ArrayList<Item> getTaskList() {
		return taskList;
	}

	public void setTaskList(ArrayList<Item> taskList) {
		this.taskList = taskList;
	}

	// Id resets on 10k
	public long getIdCounter() {
		idCounter = idCounter + 1;
		if (idCounter == 10000) {
			idCounter = 1L;
		}
		return idCounter;
	}

	public void setIdCounter(long idCounter) {
		this.idCounter = idCounter;
	}

	public void setStorageFile(File storageFile) {
		this.storageFile = storageFile;
	}

	public void setStorageFilePath(String storageFilePath) {
		if (storageFilePath.trim().equals("") || storageFilePath == null) {
			storageFilePath = DEFAULT_STORAGE_FILE_PATH;
			return;
		}
		this.storageFilePath = storageFilePath;
	}

	public String getStorageFilePath() {
		return storageFilePath;
	}

	public Settings getSettings() {
		return settings;
	}

	public void setSettings(Settings settings) {
		this.settings = settings;
	}

	/**
	 * This method initialize the GSON objects to read the storage text data
	 * file in JSON
	 */
	private void initializeGsonObjects() {
		GSON_ITEM_BUILDER.registerTypeAdapter(UserItemList.class,
				new ItemAdapter());
		GSON_ITEM_BUILDER.setPrettyPrinting();
		gsonItem = GSON_ITEM_BUILDER.create();

		GSON_SETTINGS_BUILDER.registerTypeAdapter(Settings.class,
				new SettingsAdapter());
		GSON_SETTINGS_BUILDER.setPrettyPrinting();
		gsonSettings = GSON_SETTINGS_BUILDER.create();
		logger.log(Level.INFO, "Gson objects Initialized with no errors");
	}

	/**
	 * This method initialize the settings if the settings.txt exist if not it
	 * creates a new file
	 * 
	 * @throws IOException
	 */
	private void initializeSettings() throws IOException {
		/** Check set directory folder exist a not if not create folder */
		checkDirectoryFolder();
		try {
			/** Check Settings file exist a not if not create file */
			checkSettingsFile();
		} catch (IOException e) {
			logger.log(Level.SEVERE, "Failure Settings Path: "
					+ SETTINGS_FILE_PATH);
			e.printStackTrace();
		}
		String settingsString = null;
		settingsString = FileHandler.getStringFromFile(SETTINGS_FILE_PATH);
		settings = deserializeSettingsString(settingsString);
	}

	/**
	 * This method initializes the storage.txt file(in specified location if
	 * stated in settings) or not the default location if path_directory.txt
	 * file does not exist create new storage.txt in specified directory
	 * 
	 * @throws IOException
	 */
	private void initializeStorage() throws IOException {
		// Check for user set directory in settings. If exist use directory.
		if (existStoragePath()) {
			setStorageFile(new File(settings.getStoragePath()));
			setStorageFilePath(settings.getStoragePath());
		}
		// Check for storage file if do not exist create file
		checkStorageFile();
		String storageString = FileHandler.getStringFromFile(storageFilePath);
		userItemList = deserializeStorageString(storageString);
		taskList = userItemList.getTaskArray();
		idCounter = userItemList.getIdCounter();
	}

	/**
	 * Checks storagePath exists in settings or not
	 * 
	 * @return boolean whether storage path exist or not
	 */
	private boolean existStoragePath() {
		return settings.getStoragePath() != null;
	}

	/**
	 * This method check the directory folder of the default directory file
	 * exist or not. if the directory file does not exist it creates the
	 * directory file
	 * 
	 * @return
	 */
	private boolean checkDirectoryFolder() {
		if (!DEFAULT_DIRECTORY_FILE.exists()) {
			DEFAULT_DIRECTORY_FILE.mkdir();
			return false;
		}
		return true;
	}

	//
	/**
	 * This method check storage file exist or no if doesn't it creates a new
	 * one at the user specified directory
	 * 
	 * @return storage file existence
	 * @throws IOException
	 */
	private boolean checkStorageFile() throws IOException {
		if (!storageFile.exists()) {
			// Create file if does not exist
			boolean madeFile = true;
			try{
			madeFile = storageFile.createNewFile();
			}
			// If directory cannot be created due to a same named file in
						// between,
						// feed back user with an error POPUP message
			catch(IOException e){
				storageFilePathError(CREATE_FILE_DIRECTORY_ERROR_MESSAGE);
			}						
			if (!madeFile) {
				storageFilePathError(CREATE_FILE_DIRECTORY_ERROR_MESSAGE);
				return false;
			}
//
//			storageFile.createNewFile();
			return false;
		}
		// If the file is a directory set to default storage path and return a error dialog
		if(storageFile.isDirectory()){
			storageFilePathError(LIGHT_STORAGE_ERROR);
			storageFilePath = DEFAULT_STORAGE_FILE_PATH;
			storageFile = new File(DEFAULT_STORAGE_FILE_PATH);
			return false;
		}
		return true;
	}
	

	// Cannot create file if parentFile is not directory or file with same name
	// already exsit
	public void storageFilePathError(String input) {
		logger.log(Level.WARNING, CREATE_FILE_DIRECTORY_ERROR_MESSAGE);
		storageFilePath = DEFAULT_STORAGE_FILE_PATH;
		Alert alert = new Alert(AlertType.ERROR);
		alert.setTitle(ERROR_DIALOG_TITLE);
		alert.setHeaderText(ERROR_DIALOG_HEADER);
		alert.setContentText(CREATE_FILE_DIRECTORY_ERROR_MESSAGE);

		alert.showAndWait();
	}

	/**
	 * This method create settings file if it doesn't exist
	 * 
	 * @throws IOException
	 */
	private void checkSettingsFile() throws IOException {
		if (!settingsFile.exists()) {
			settingsFile.createNewFile();

		}
		return;
	}

	/**
	 * This method check whether the input string is empty or null or not
	 * 
	 * @param string
	 * @return boolean whether string is empty or not
	 */
	private boolean checkEmptyString(String string) {
		if (string.equals("") || string.equals(null)) {
			return true;
		} else {
			return false;
		}

	}

	/**
	 * This method Use the Gson library to get a Storage object from String
	 * 
	 * @param jsonString
	 * @return
	 * @throws IOException
	 */
	private UserItemList deserializeStorageString(String jsonString)
			throws IOException {
		UserItemList userTaskList = null;
		if (checkEmptyString(jsonString)) {
			UserItemList utl = new UserItemList("Not Set",
					new ArrayList<Item>());
			utl.setIdCounter(0);
			taskList = new ArrayList<Item>();
			return utl;
		}
		try {
			userTaskList = gsonItem.fromJson(jsonString, UserItemList.class);
		} // Prints out error dialog when error occurs
		catch (Exception e) {
			System.err.println("ERROR IN STORAGE (deserializeStorageString): "
					+ e);
			Alert alert = new Alert(AlertType.ERROR);
			alert.setTitle(ERROR_DIALOG_TITLE);
			alert.setHeaderText(ERROR_DIALOG_HEADER);
			alert.setContentText(String.format(FILE_READ_ERROR_MESSAGE,
					"STORAGE"));

			alert.showAndWait();
		}
		return userTaskList;
	}

	/**
	 * This method Use the Gson library to get a Settings object from String
	 * 
	 * @param jsonString
	 * @return
	 * @throws IOException
	 */
	private Settings deserializeSettingsString(String jsonString)
			throws IOException {
		if (checkEmptyString(jsonString)) {
			Settings defaultSettings = new Settings(DEFAULT_STORAGE_FILE_PATH,
					"eff3f6", "616060", "000000");
			defaultSettings.setStoragePath(DEFAULT_STORAGE_FILE_PATH);
			final String json = gsonSettings.toJson(defaultSettings);
			FileHandler.writeStringToFile(settingsFile, json);
			return defaultSettings;
		}
		// Prints out error dialog when error occurs
		try {
			settings = gsonSettings.fromJson(jsonString, Settings.class);
		}
		// If error in reading storage file pop up an error dialog to guide user
		catch (Exception e) {
			Alert alert = new Alert(AlertType.ERROR);
			alert.setTitle(ERROR_DIALOG_TITLE);
			alert.setHeaderText(ERROR_DIALOG_HEADER);
			alert.setContentText(String.format(FILE_READ_ERROR_MESSAGE,
					"SETTINGS"));
			alert.showAndWait();
			System.err
					.println("ERROR IN SETTINGS (deserializeSettingsString): "
							+ e);

		}
		return gsonSettings.fromJson(jsonString, Settings.class);
	}

	/**
	 * This method save the current userTaskList to the storage text file
	 * 
	 * @throws IOException
	 */
	public void saveStorage() throws IOException {
		userItemList.setTaskArray(taskList);
		userItemList.setIdCounter(idCounter);
		final String json = gsonItem.toJson(userItemList);
		FileHandler.writeStringToFile(storageFile, json);
	}

	/**
	 * This method save the current Settings to the settings text file
	 * 
	 * @throws IOException
	 */
	public void saveSettings() throws IOException {
		assert settings != null : "Settings not set";
		settings.setStoragePath(storageFilePath);
		final String json = gsonSettings.toJson(settings);
		FileHandler.writeStringToFile(settingsFile, json);
	}
}
```
###### src\Test\GsonTest.java
``` java
 *
 */

public class GsonTest {
	// UserItemList objects for test
	GsonBuilder GSON_ITEM_BUILDER;
	Gson gsonItem;
	// Items to initialize at before
	UserItemList taskListInput;
	Item item1;
	Item item2;
	long initialCounter;

	// Settings Objects for test
	GsonBuilder GSON_SETTINGS_BUILDER = new GsonBuilder();
	Gson gsonSettings;
	Settings settings;
	private final String TEST_STORAGE_STRING = "TEST";

	/**
	 * Create a Gson String builder to create a text file. we register
	 * UserItemList to write this Object into a string. So a Gsonbuilder will
	 * create a instance of gson to do this.
	 */
	@Before
	public void initObjects() {
		// Gson objects for UserItemList
		GSON_ITEM_BUILDER = new GsonBuilder();
		GSON_ITEM_BUILDER.registerTypeAdapter(UserItemList.class,
				new ItemAdapter());
		GSON_ITEM_BUILDER.setPrettyPrinting();
		gsonItem = GSON_ITEM_BUILDER.create();
		// Gson Objects for settings
		final GsonBuilder GSON_SETTINGS_BUILDER = new GsonBuilder();
		GSON_SETTINGS_BUILDER.registerTypeAdapter(Settings.class,
				new SettingsAdapter());
		GSON_SETTINGS_BUILDER.setPrettyPrinting();
		gsonSettings = GSON_SETTINGS_BUILDER.create();

		// Add userItemList data
		taskListInput = new UserItemList();
		item1 = new Item(1L, "Event", "It is a sunny day", "High",
				"I want to swim", "Done", "red label", new Date(), new Date());

		item2 = new Item(2L, "Task", "It is a rainny day", "Medium",
				"I want to study", "Undone", "blue label", new Date(),
				new Date());
		initialCounter = 0L;
		taskListInput.setUserName("Wei Lip");
		taskListInput.setIdCounter(initialCounter);
		ArrayList<Item> tArray = new ArrayList<>();
		tArray.add(item1);
		tArray.add(item2);
		taskListInput.setTaskArray(tArray);

		// Add Settings data
		settings = new Settings(TEST_STORAGE_STRING, "eff3f6", "616060",
				"000000");
	}

	/********************* Helper Methods **************************************/

	public boolean isSameItemList(ArrayList<Item> listA, ArrayList<Item> listB) {
		int lengthA = listA.size();
		int lengthB = listB.size();
		boolean sameList = true;
		if (lengthA != lengthB) {
			return false;
		} else {
			// Test every aspect of the item value are equals to each other
			for (int i = 0; i < lengthA; i++) {
				// If the previous item was not the same return false.
				if (!sameList) {
					return false;
				}
				Item currentItemA = listA.get(0);
				Item currentItemB = listB.get(0);

				sameList = currentItemA.getId().equals(currentItemB.getId());
				sameList = currentItemA.getTitle().equals(
						currentItemB.getTitle());
				sameList = currentItemA.getDescription().equals(
						currentItemB.getDescription());
				sameList = currentItemA.getLabel().equals(
						currentItemB.getLabel());
				sameList = currentItemA.getPriority().equals(
						currentItemB.getPriority());
				sameList = currentItemA.getTitle().equals(
						currentItemB.getTitle());
				sameList = currentItemA.getTitle().equals(
						currentItemB.getTitle());
			}
			return sameList;
		}

	}

	/********************* Unit Tests **************************************/

	/**
	 * Test the correct reading and writing of UserItemList object into the text
	 * file
	 */
	@Test
	public void testGsonUserItemList() {
		final String itemJson = gsonItem.toJson(taskListInput);

		// get Object from above json string and test whether it writes to the
		// object with same values or not
		final UserItemList taskListOutput = gsonItem.fromJson(itemJson,
				UserItemList.class);

		assertEquals(taskListOutput.getUserName(), taskListInput.getUserName());
		assertEquals(taskListOutput.getIdCounter(),
				taskListInput.getIdCounter());
		ArrayList<Item> taskList1 = taskListOutput.getTaskArray();
		ArrayList<Item> taskList2 = taskListInput.getTaskArray();
		assertTrue(isSameItemList(taskList1, taskList2));

	}

	/**
	 * Test the correct reading and writing of Settings object into the text
	 * file
	 */
	@Test
	public void testGsonSettings() {
		final String settingsJson = gsonSettings.toJson(settings);

		final Settings settingsFromString = gsonSettings.fromJson(settingsJson,
				Settings.class);
		assertEquals(settingsFromString.getStoragePath(), TEST_STORAGE_STRING);
		assertEquals(settingsFromString.getBackgroundColour(), "eff3f6");
		assertEquals(settingsFromString.getReturnMsgColour(), "616060");
		assertEquals(settingsFromString.getInputTxtColour(), "000000");
	}
}
```
###### src\Test\TestStorage.java
``` java
 */
public class TestStorage {
	/** Storage directory for testing */
	private final String DEFAULT_FILE_DIRECTORY = "test";
	private final String DEFAULT_FILE_NAME = "Storage.txt";
	private final String DEFAULT_STORAGE_FILE_PATH_TESTING = DEFAULT_FILE_DIRECTORY
			+ "/" + DEFAULT_FILE_NAME;

	/** Gson testing for reading and saving */
	GsonBuilder gsonItemBuilder;
	Gson gsonItem;
	UserItemList taskListInput;

	/** Storage Items for testing */
	Item item1;
	Item item2;
	Item item3;
	Item item4;
	Storage storageStub;
	String originalStorageFilePath;

	/**
	 * Initialization of stub and item variables for adding later. Create a gson
	 * Item builder which will be used to create a JSON String from UserItemList
	 * vice-versa. So we register UserItemList to write this Object into a
	 * string. So a Gsonbuilder will create a gson instance to do this.
	 */
	@Before
	public void initGson() {

		gsonItemBuilder = new GsonBuilder();
		gsonItemBuilder.registerTypeAdapter(UserItemList.class,
				new ItemAdapter());
		gsonItemBuilder.setPrettyPrinting();
		gsonItem = gsonItemBuilder.create();
	}

	/**
	 * Initialize variables from empty storage and create 4 items for testing
	 * later. Change the storage file path to new empty folder for testing to so
	 * that it would not affect the actual folder data
	 */
	@Before
	public void initStorage() throws ParseException, IOException {

		storageStub = new Storage();
		storageStub.init();

		/** Save the Orignal file path and change back to it later */
		originalStorageFilePath = storageStub.getStorageFilePath();

		/** Create new storage for test */
		File testFile = new File(DEFAULT_STORAGE_FILE_PATH_TESTING);
		testFile.delete();

		/** Set to testing location and initialize storage */
		storageStub.setStorageFilePath(DEFAULT_STORAGE_FILE_PATH_TESTING);
		storageStub.saveSettings();

		/** Reinitialize storage with new storagefile */
		storageStub.init();
		addItems(storageStub.getTaskList());
	}

	/********************* Helper Methods * @throws IOException **************************************/

	/**
	 * This method compares the 2 list in the parameters whether they have the
	 * same items or not
	 * 
	 * @param listA
	 * @param listB
	 * @return boolean value of comparing the 2 list
	 */
	public boolean isSameItemList(ArrayList<Item> listA, ArrayList<Item> listB) {
		int lengthA = listA.size();
		int lengthB = listB.size();
		boolean sameList = true;
		if (lengthA != lengthB) { 
			return false;
		} else {
			/** Test every aspect of the item value are equals to each other */
			for (int i = 0; i < lengthA; i++) {
				// If the previous item was not the same return false.
				if (!sameList) {
					return false;
				}
				Item currentItemA = listA.get(0);
				Item currentItemB = listB.get(0);

				sameList = currentItemA.getId().equals(currentItemB.getId());
				sameList = currentItemA.getTitle().equals(
						currentItemB.getTitle());
				sameList = currentItemA.getDescription().equals(
						currentItemB.getDescription());
				sameList = currentItemA.getLabel().equals(
						currentItemB.getLabel());
				sameList = currentItemA.getPriority().equals(
						currentItemB.getPriority());
				sameList = currentItemA.getTitle().equals(
						currentItemB.getTitle());
				sameList = currentItemA.getTitle().equals(
						currentItemB.getTitle());
			}
			return sameList;
		}

	}

	/**
	 * This method add items for testing into the list from the parameter
	 * 
	 * @param list
	 * @throws ParseException
	 */
	public void addItems(ArrayList<Item> list) throws ParseException {

		SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm");
		sdf.parse("Wed, 4 Jul 2016 12:08");

		item1 = new Item(1L, "event", "Swim", "High", "Nice day", "Done",
				"red label", sdf.parse("Wed, 04 Jan 2016 12:08"),
				sdf.parse("Wed, 30 Jan 2016 12:08"));

		item2 = new Item(2L, "task", "Sleep", "Medium", "yawn", "Undone",
				"blue label", sdf.parse("Wed, 04 Jul 2016 12:08"),
				sdf.parse("Wed, 11 Jul 2016 12:08"));

		item3 = new Item(3L, "task", "Fight", "Medium", "Muay thai", "Undone",
				"blue label", sdf.parse("Wed, 01 Jul 2016 12:08"),
				sdf.parse("Wed, 10 Jul 2016 12:08"));

		item4 = new Item(4L, "task", "Mug", "Medium", "I want to study",
				"Undone", "blue label", new Date(), new Date());
		list.add(item1);
		list.add(item2);
		list.add(item3);
		list.add(item4);
	}

	/**
	 * This method add completed items into the list for testing
	 * 
	 * @param lst
	 * @throws ParseException
	 */
	public void addCompletedItems(ArrayList<Item> lst) throws ParseException {
		SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm");
		sdf.parse("Wed, 4 Jul 2016 12:08");

		Item doneItem1 = new Item(1L, "event", "Swim", "High", "Nice day",
				"completed", "red label", sdf.parse("Wed, 04 Jan 2016 12:08"),
				sdf.parse("Wed, 30 Jan 2016 12:08"));

		Item doneItem2 = new Item(2L, "task", "Sleep", "Medium", "yawn",
				"completed", "blue label", sdf.parse("Wed, 04 Jul 2016 12:08"),
				sdf.parse("Wed, 11 Jul 2016 12:08"));

		Item doneItem3 = new Item(3L, "task", "Fight", "Medium", "Muay thai",
				"completed", "blue label", sdf.parse("Wed, 01 Jul 2016 12:08"),
				sdf.parse("Wed, 10 Jul 2016 12:08"));

		Item doneItem4 = new Item(4L, "task", "Mug", "Medium",
				"I want to study", "completed", "blue label", new Date(),
				new Date());
		lst.add(doneItem1);
		lst.add(doneItem2);
		lst.add(doneItem3);
		lst.add(doneItem4);
	}

	public void addTodayEventandTask(ArrayList<Item> lst) throws ParseException {
		Item doneItem1 = new Item(1L, "event", "Swim", "High", "Nice day",
				"completed", "red label", new Date(), new Date());

		Item doneItem2 = new Item(2L, "task", "Sleep", "Medium", "yawn",
				"completed", "blue label", new Date(), new Date());
		lst.add(doneItem1);
		lst.add(doneItem2);
	}

	/********************* UNIT TEST CASES * @throws IOException **************************************/

	/**
	 * Tests whether the file specified will be created when the constructor is
	 * called.
	 * 
	 * @throws IOException
	 */
	@Test
	public void testInitialization() throws IOException {
		Storage testStorage = new Storage();
		testStorage.init();
		assertNotNull(testStorage.getIdCounter());
		assertNotNull(testStorage.getStorageFilePath());
		assertNotNull(testStorage.getTaskList());
		assertNotNull(testStorage.getUserTaskList());
	}

	/**
	 * This method test whether getIdCounter increments itself a not
	 * 
	 * @throws IOException
	 */
	@Test
	public void correctIdRead() throws IOException {
		assertEquals(storageStub.getUserTaskList().getIdCounter() + 1,
				storageStub.getIdCounter());
	}

	/**
	 * The code to initialize the storageFilePath is done in the method
	 * initstorage. So now we will just check whether the path is set correctly
	 * a not
	 * 
	 * @throws SecurityException
	 * @throws IOException
	 */
	@Test
	public void testWriteToSettings() throws SecurityException, IOException {
		assertEquals(storageStub.getStorageFilePath(),
				DEFAULT_STORAGE_FILE_PATH_TESTING);
	}

	/**
	 * This method will add the items to storage and save it to the storage text
	 * file And test whether we can get back the same items using our gson file
	 * reader.
	 * 
	 * @throws IOException
	 */
	@Test
	public void testAddAndSave() throws IOException {
		// addItems(storageStub.getTaskList());
		storageStub.saveStorage();
		// Read Storage file at location storageFilePath(Tested above) and
		// check for equivalence by reading storage file with Gson
		String jsonUserItemList = FileHandler
				.getStringFromFile(DEFAULT_STORAGE_FILE_PATH_TESTING);
		UserItemList taskListOutput = gsonItem.fromJson(jsonUserItemList,
				UserItemList.class);
		assertTrue(isSameItemList(storageStub.getTaskList(),
				taskListOutput.getTaskArray()));
	}

	/**
	 * This method will delete the items to storage and save it to the storage
	 * text file And test whether we can get back the same items using our gson
	 * file reader.
	 * 
	 * @throws IOException
	 */
	@Test
	public void testDeleteAndSave() throws IOException {
		// addItems(storageStub.getTaskList());
		storageStub.getTaskList().remove(2);
		storageStub.getTaskList().remove(1);
		storageStub.saveStorage();

		// Same code as above to check for equivalence
		String jsonUserItemList = FileHandler
				.getStringFromFile(DEFAULT_STORAGE_FILE_PATH_TESTING);
		UserItemList taskListOutput = gsonItem.fromJson(jsonUserItemList,
				UserItemList.class);
		assertTrue(isSameItemList(storageStub.getTaskList(),
				taskListOutput.getTaskArray()));
	}

	/**
	 * This method will edit the items to storage and save it to the storage
	 * text file And test whether we can get back the same items using our gson
	 * file reader.
	 * 
	 * @throws IOException
	 */
	@Test
	public void testEditAndSave() throws IOException {
		// addItems(storageStub.getTaskList());
		storageStub.getTaskList().get(0).setTitle("Testing title");
		storageStub.getTaskList().get(0).setTitle("Testing title 2");
		storageStub.saveStorage();

		// Same code as above to check for equivalence
		String jsonUserItemList = FileHandler
				.getStringFromFile(DEFAULT_STORAGE_FILE_PATH_TESTING);
		UserItemList taskListOutput = gsonItem.fromJson(jsonUserItemList,
				UserItemList.class);
		assertTrue(isSameItemList(storageStub.getTaskList(),
				taskListOutput.getTaskArray()));
	}

	/**
	 * This method test whether the list classifier filters the item list
	 * correctly a not.
	 */
	@Test
	public void testListClassifierTask() {
		ArrayList<Item> temp = ListClassifier.getTaskList(storageStub
				.getTaskList());
		for (int i = 0; i < temp.size(); i++) {
			assertTrue(temp.get(i).getType().equals("task"));
		}
	}

	/**
	 * This method test whether the list classifier filters the item list
	 * correctly a not.
	 */
	@Test
	public void testListClassifierDoneTask() throws ParseException {
		addCompletedItems(storageStub.getTaskList());
		ArrayList<Item> temp = ListClassifier.getDoneTaskList(storageStub
				.getTaskList());
		for (Item item : temp) {
			assertTrue(item.getType().equals("task"));
			assertTrue(item.getStatus().equals("completed"));
		}
	}

	/**
	 * From the item list get a sublist containing all the Events from the main
	 * list
	 */
	@Test
	public void testListClassifierEvent() {
		ArrayList<Item> temp = ListClassifier.getEventList(storageStub
				.getTaskList());
		for (Item item : temp) {
			assertTrue(item.getType().equals("event"));
		}
	}

	// Check does it returns the correct number of task today
	@Test
	public void testListClassifierTodayNumOfTask() throws ParseException {
		ArrayList<Item> temp = storageStub.getTaskList();
		addTodayEventandTask(temp);
		// @Before adds one today task and the other one from the above method
		assertEquals(ListClassifier.getTodayTask(temp), "2");

	}

	/**
	 * Check whether it returns the correct number of event today
	 * 
	 * @throws ParseException
	 */
	@Test
	public void testListClassifierTodayNumOfEvent() throws ParseException {
		ArrayList<Item> temp = storageStub.getTaskList();
		addTodayEventandTask(temp);
		assertEquals(ListClassifier.getTodayEvent(temp), "1");

	}

	/**
	 * This method test whether the list classifier filters the item list
	 * correctly a not.
	 */
	@Test
	public void testListClassifierDoneEvent() throws ParseException {
		addCompletedItems(storageStub.getTaskList());
		ArrayList<Item> temp = ListClassifier.getDoneEventList(storageStub
				.getTaskList());
		for (Item item : temp) {
			assertTrue(item.getType().equals("event"));
			assertTrue(item.getStatus().equals("completed"));
		}
	}

	/**
	 * This method test whether the list classifier filters the item list by
	 * priority correctly a not.
	 */
	@Test
	public void testClassifyPriority() {
		ObservableList<Item> temp = ListClassifier.getSpecifiedPrirorirty(
				FXCollections.observableArrayList(storageStub.getTaskList()),
				"High");
		for (Item item : temp) {
			assertTrue(item.getPriority().equals("High"));
		}
	}

	/** Change back the settings of the original User or tester */
	@After
	public void returnToOriginalSettings() throws IOException {
		storageStub.setStorageFilePath(originalStorageFilePath);
		storageStub.saveSettings();
	}

}
```
###### src\Test\TestSystem.java
``` java
 *
 */
public class TestSystem {

	POMPOM pompom;
	Date currentDate;
	ArrayList<Item> taskList;
	PrettyTimeParser timeParser;

	/**
	 * Method to initialize variables
	 * 
	 * @throws IOException
	 * 
```
###### src\Test\TestSystem.java
``` java
	 */
	@Before
	public void init() throws IOException {
		pompom = new POMPOM();
		currentDate = new Date();
		timeParser = new PrettyTimeParser();
		pompom.saveSettings("SystemTest.txt");
		pompom.getStorage().init();
		taskList = POMPOM.getStorage().getTaskList();
		POMPOM.getStorage().saveStorage();
	}

	/********************************* Helper Methods ***************************************/
	/**
	 * Using the library we use in the pompom program to parse the date string.
	 * returns a date *
	 * 
	 * @param date
	 * @return Date
	 */
	private Date parseFromDate(String date) {
		List<Date> startDate;
		if (date != null) {
			startDate = timeParser.parse(date);

			if (startDate.size() == 0) {
				return null;
			} else {
				return startDate.get(0);
			}

		} else {
			return null;
		}

	}

	public boolean isSameItemList(ArrayList<Item> listA, ArrayList<Item> listB) {
		int lengthA = listA.size();
		int lengthB = listB.size();
		boolean sameList = true;
		if (lengthA != lengthB) {
			return false;
		} else {
			/** Test every aspect of the item value are equals to each other */
			for (int i = 0; i < lengthA; i++) {
				// If the previous item was not the same return false.
				if (!sameList) {
					return false;
				}
				Item currentItemA = listA.get(0);
				Item currentItemB = listB.get(0);

				sameList = testIsSameItem(currentItemA, currentItemB);
			}
			return sameList;
		}

	}

	public boolean testIsSameItem(Item itemA, Item itemB) {
		if (itemA == null && itemB == null) {
			return true;
		} else if (itemA == null && itemB != null) {
			return false;
		} else if (itemA != null && itemB == null) {
			return false;
		} else {
			// sameItem = testObjectEquivilence(itemA.getId(), itemB.getId());
			// No description for now
			// sameItem = itemA.getDescription().equals(itemB.getDescription());
			if (!testStringEquivalence(itemA.getTitle(), itemB.getTitle())) {
				return false;
			}
			if (!testStringEquivalence(itemA.getLabel(), itemB.getLabel())) {

				return false;

			}
			if (!testStringEquivalence(itemA.getPriority(), itemB.getPriority())) {
				return false;
			}
			if (!testStringEquivalence(itemA.getSd(), itemB.getSd())) {
				return false;
			}
			if (!testStringEquivalence(itemA.getEd(), itemB.getEd())) {
				return false;
			}
			return true;
		}

	}

	public boolean testStringEquivalence(String stringA, String StringB) {
		if (stringA == null && StringB == null) {
			return true;
		} else if (stringA == null && StringB != null) {
			return false;
		} else if (stringA != null && StringB == null) {
			return false;
		} else {
			return stringA.equals(StringB);
		}

	}

	/********************************* End of Helper Methods ***************************************/

	/**
	 * Try adding a basic task and test whether it returns the correct title a
	 * not
	 * 
```
###### src\Test\TestSystem.java
``` java
	 */
	@Test
	public void testAddTitleOnly() {

		// Make sure subsequent tests start from clean slate
		taskList.clear();

		String userCommand = "add do project";
		String returnMsg = pompom.execute(userCommand);

		// check if the add command returns the right status message
		assertEquals("Task added", returnMsg);

		// check if the taskList contain the added task
		Item addedTask = taskList.get(0);
		assertEquals("do project", addedTask.getTitle());

	}

	/**
	 * Simple test to check whether add
	 */
	@Test
	public void testUndoAdd() {

		// Make sure subsequent tests start from clean slate
		taskList.clear();

		String userCommand = "add do project";
		String returnMsg = pompom.execute(userCommand);

		// check if the add command returns the right status message
		assertEquals("Task added", returnMsg);

		// check if the taskList contain the added task
		Item addedTask = taskList.get(0);
		assertEquals("do project", addedTask.getTitle());

		String undoCommand = "undo";
		returnMsg = pompom.execute(undoCommand);

		// check if the add command returns the right status message
		assertEquals(UndoCommand.MESSAGE_UNDO, returnMsg);
		assertEquals(0, taskList.size());

	}

	/**
	 *
	 * Full test for adding events and check storage whether desired events are
	 * added properly
	 * 
```
###### src\Test\TestSystem.java
``` java
	 */
	@Test
	public void testAddAndDeleteEvent() {
		// Make sure subsequent tests start from clean slate
		taskList.clear();
		// With all required fields except priority and label(Optional)
		String userCommand_1 = "event clubbing f:3 apr 2018 e:3 may 2019";
		String returnMsg_1 = pompom.execute(userCommand_1);
		// Test With all fields
		String userCommand_2 = "event Afternoon Nap f:today l:Sleep e:tomorrow p:h";
		String returnMsg_2 = pompom.execute(userCommand_2);
		// Test with all required fields except label and additional space
		// Jumble up delimiters
		String userCommand_3 = "event Trying for 3 syllabus title f:next monday p:high e:next year          ";
		String returnMsg_3 = pompom.execute(userCommand_3);
		// Test with all required fields except Priority Jumble up delimiters
		// again
		String userCommand_4 = "event Test 4 f:12/28/2015 l:test e:01/28/2016";
		String returnMsg_4 = pompom.execute(userCommand_4);

		// check if the add command returns the right status message
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Event"),
				returnMsg_1);
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Event"),
				returnMsg_2);
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Event"),
				returnMsg_3);
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Event"),
				returnMsg_4);

		// Expected dates from library
		Date addedStartDate_1 = parseFromDate("3 apr 2018");
		Date addedEndDate_1 = parseFromDate("3 may 2019");

		Date addedStartDate_2 = parseFromDate("today");
		Date addedEndDate_2 = parseFromDate("tomorrow");

		Date addedStartDate_3 = parseFromDate("next monday");
		Date addedEndDate_3 = parseFromDate("next year");

		Date addedStartDate_4 = parseFromDate("12/28/2015");
		Date addedEndDate_4 = parseFromDate("01/28/2016");

		// Check if the task values are added correctly to the storage a not
		Item expectedAddedTask_1 = new Item(null, POMPOM.LABEL_EVENT,
				"clubbing", null, null, POMPOM.STATUS_PENDING, null,
				addedStartDate_1, addedEndDate_1);
		Item addedTask_1 = taskList.get(0);
		assertTrue(testIsSameItem(expectedAddedTask_1, addedTask_1));

		Item expectedAddedTask_2 = new Item(1L, POMPOM.LABEL_EVENT,
				"Afternoon Nap", "High", null, POMPOM.STATUS_ONGOING, "Sleep",
				addedStartDate_2, addedEndDate_2);
		Item addedTask_2 = taskList.get(1);
		assertTrue(testIsSameItem(expectedAddedTask_2, addedTask_2));

		Item expectedAddedTask_3 = new Item(null, POMPOM.LABEL_EVENT,
				"Trying for 3 syllabus title", "High", null,
				POMPOM.STATUS_ONGOING, null, addedStartDate_3, addedEndDate_3);
		Item addedTask_3 = taskList.get(2);
		assertTrue(testIsSameItem(addedTask_3, expectedAddedTask_3));
		Item expectedAddedTask_4 = new Item(null, POMPOM.LABEL_EVENT, "Test 4",
				null, null, POMPOM.STATUS_COMPLETED, "test", addedStartDate_4,
				addedEndDate_4);
		Item addedTask_4 = taskList.get(3);
		assertTrue(testIsSameItem(expectedAddedTask_4, addedTask_4));

		// Test a simple delete on a event
		String id = taskList.get(0).getId().toString();
		String userCommand_5 = "delete " + id;

		
		String returnMsg_5 = pompom.execute(userCommand_5);

		assertEquals(
				String.format(String.format(DelCommand.MESSAGE_TASK_DELETED,
						id, POMPOM.LABEL_EVENT), id), returnMsg_5);
		assertEquals(3, taskList.size());
	}

	/**
	 * Test recurring add the correct number of task a not. We are just going
	 * check the number of task added here because add recurring uses the Add
	 * command to add events one by one.
	 */
	@Test
	public void testAddRecurringEvent() {
		// Reset task list and add 21 events daily from 04/11 to 01/05
		taskList.clear();
		String userCommand_1 = "event asd f:04/11/2016 e:tomorrow p:h r:daily until 01 may 2016";
		String returnMsg_1 = pompom.execute(userCommand_1);

		assertEquals(String.format(AddRecurringCommand.MESSAGE_RECURRING, ""),
				returnMsg_1);
		assertEquals(21, taskList.size());

		// Reset task list and add 8 events. Weekly from 04/11 to 01/05
		taskList.clear();
		String userCommand_2 = "event asd f:04/11/2016 e:tomorrow p:h r:weekly until 30 may 2016";
		String returnMsg_2 = pompom.execute(userCommand_2);

		assertEquals(String.format(AddRecurringCommand.MESSAGE_RECURRING, ""),
				returnMsg_2);
		assertEquals(8, taskList.size());

		// Reset task list and add 4 events. biweekly from 04/11 to 01/05
		taskList.clear();
		String userCommand_3 = "event asd f:04/11/2016 e:tomorrow p:h r:biweekly until 30 may 2016";
		String returnMsg_3 = pompom.execute(userCommand_3);

		assertEquals(String.format(AddRecurringCommand.MESSAGE_RECURRING, ""),
				returnMsg_3);
		assertEquals(4, taskList.size());

		// Reset task list and add 2 events. r:monthly from 04/11 to 05/06
		taskList.clear();
		String userCommand_4 = "event asd f:04/11/2016 e:tomorrow p:h r:monthly until 05 june 2016";
		String returnMsg_4 = pompom.execute(userCommand_4);

		assertEquals(String.format(AddRecurringCommand.MESSAGE_RECURRING, ""),
				returnMsg_4);
		assertEquals(2, taskList.size());

		// Reset task list and add 2 events. r:monthly from 04/11 to 05/06
		taskList.clear();
		String userCommand_5 = "event asd f:04/11/2016 e:tomorrow p:h r:annually until 05 mar 2017";
		String returnMsg_5 = pompom.execute(userCommand_5);

		assertEquals(String.format(AddRecurringCommand.MESSAGE_RECURRING, ""),
				returnMsg_5);
		assertEquals(1, taskList.size());

		// Reset task list and add 2 events. r:daily from 11 apr to 30 apr 20
		// days exclude 6 DAYS
		// 13 APR TO 18 apr. which totals up too 14 events
		taskList.clear();
		String userCommand_6 = "event asd f:04/11/2016 e:tomorrow p:h r:daily until 30 apr 2016 x:13 apr to 18 apr";
		String returnMsg_6 = pompom.execute(userCommand_6);

		assertEquals(String.format(AddRecurringCommand.MESSAGE_RECURRING, ""),
				returnMsg_6);
		assertEquals(14, taskList.size());
	}

	/**
	 * This method conducts test on the possible bad commands at least on test
	 * heuristics methods are self explanatory
	 * 
	 * @throws IOException
	 */
	@Test
	public void testAddEventBadCommands() throws IOException {
		int initialSize = taskList.size();
		String badUserCommand_1 = "event clubbing f: e:3 may 2019";
		String badReturnMsg_1 = pompom.execute(badUserCommand_1);

		// check if the add command returns the right invalid message
		assertEquals(String.format(AddParser.MESSAGE_DATE_ERROR, ""),
				badReturnMsg_1);
		// Make sure nothing is added
		assertEquals(initialSize, POMPOM.getStorage().getTaskList().size());

		String badUserCommand_2 = "event clubbing  e:3 may 2019";
		String badReturnMsg_2 = pompom.execute(badUserCommand_2);

		assertEquals(String.format(AddParser.MESSAGE_DATES_SPECIFIED, ""),
				badReturnMsg_2);
		assertEquals(initialSize, taskList.size());

		String badUserCommand_4 = "eveana e:3 may 2019";
		String badReturnMsg_4 = pompom.execute(badUserCommand_4);

		assertEquals(String.format(Parser.INVALID_CMD_MESSAGE, "eveana"),
				badReturnMsg_4);
		assertEquals(initialSize, taskList.size());

		String badUserCommand_5 = "event asd e:asd";
		String badReturnMsg_5 = pompom.execute(badUserCommand_5);

		assertEquals(String.format(AddParser.MESSAGE_DATE_ERROR, "asd"),
				badReturnMsg_5);
		assertEquals(initialSize, taskList.size());

		String badUserCommand_6 = "event asd f:3 may 2015 e:2 may 2015";
		String badReturnMsg_6 = pompom.execute(badUserCommand_6);

		assertEquals(AddParser.MESSAGE_END_BEFORE_FROM, badReturnMsg_6);
		assertEquals(initialSize, taskList.size());

		String badUserCommand_7 = "event asd f:3 may 2015 e:2 may 2015";
		String badReturnMsg_7 = pompom.execute(badUserCommand_7);

		assertEquals(AddParser.MESSAGE_END_BEFORE_FROM, badReturnMsg_7);
		assertEquals(initialSize, taskList.size());

		String badUserCommand_8 = "event asd f:today e:tomorrow r:daily asdatil 01 may 2017 x:asdf";
		String badReturnMsg_8 = pompom.execute(badUserCommand_8);

		assertEquals(String.format(AddParser.MESSAGE_RECURRING_ERROR,
				"daily asdatil 01 may 2017"), badReturnMsg_8);
		assertEquals(initialSize, taskList.size());

		String badUserCommand_9 = "event asd f:today e:tomorrow r:daily until 01 may 2017 x:asdf";
		String badReturnMsg_9 = pompom.execute(badUserCommand_9);

		assertEquals(String.format(AddParser.MESSAGE_EXCLUSION_ERROR, "asdf"),
				badReturnMsg_9);
		assertEquals(initialSize, taskList.size());

		String badUserCommand_10 = "event asd f:today e:tomorrow p:ragge r:daily until 01 may 2017 today to 01 may 2017";
		String badReturnMsg_10 = pompom.execute(badUserCommand_10);

		assertEquals(String.format(AddParser.MESSAGE_PRIORITY_ERROR, "ragge"),
				badReturnMsg_10);
		assertEquals(initialSize, taskList.size());

		String badUserCommand_11 = "add asd e:tomorrow p:h r:daily until 01 may 2017 today to 01 may 2017";
		String badReturnMsg_11 = pompom.execute(badUserCommand_11);

		assertEquals(AddParser.MESSAGE_START_DATE_SPECIFIED, badReturnMsg_11);
		assertEquals(initialSize, taskList.size());

	}

	/**
	 * Full test for adding task. Again using the at least once heuristic to
	 * make sure that the fields are working
	 */
	@Test
	public void testAddTask() {
		// Make sure subsequent tests start from clean slate
		taskList.clear();
		// Test with only end date
		String userCommand_1 = "add clubbing e:3 may 2019";
		String returnMsg_1 = pompom.execute(userCommand_1);

		// Test With all fields
		String userCommand_2 = "add Afternoon Nap f:today l:Sleep  p:h";
		String returnMsg_2 = pompom.execute(userCommand_2);
		// Test with all required fields except label and additional space
		// Jumble up delimiters
		String userCommand_3 = "add Trying for 3 syllabus title f:next monday p:high e:next year          ";
		String returnMsg_3 = pompom.execute(userCommand_3);
		// Test Add task with no date
		String userCommand_4 = "add Test 4  l:test ";
		String returnMsg_4 = pompom.execute(userCommand_4);
		// check if the add command returns the right status message
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Task"),
				returnMsg_1);
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Task"),
				returnMsg_2);
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Task"),
				returnMsg_3);
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Task"),
				returnMsg_4);

		// Expected dates from library
		Date addedStartDate_1 = null;
		Date addedEndDate_1 = parseFromDate("3 may 2019");

		Date addedStartDate_2 = parseFromDate("today");
		Date addedEndDate_2 = null;

		Date addedStartDate_3 = parseFromDate("next monday");
		Date addedEndDate_3 = parseFromDate("next year");

		Date addedStartDate_4 = null;
		Date addedEndDate_4 = null;

		// Check if the task values are added correctly to the storage a not
		Item expectedAddedTask_1 = new Item(null, POMPOM.LABEL_EVENT,
				"clubbing", null, null, POMPOM.STATUS_PENDING, null,
				addedStartDate_1, addedEndDate_1);
		Item addedTask_1 = taskList.get(0);
		assertTrue(testIsSameItem(expectedAddedTask_1, addedTask_1));

		Item expectedAddedTask_2 = new Item(1L, POMPOM.LABEL_EVENT,
				"Afternoon Nap", "High", null, POMPOM.STATUS_ONGOING, "Sleep",
				addedStartDate_2, addedEndDate_2);
		Item addedTask_2 = taskList.get(1);
		assertTrue(testIsSameItem(expectedAddedTask_2, addedTask_2));

		Item expectedAddedTask_3 = new Item(null, POMPOM.LABEL_EVENT,
				"Trying for 3 syllabus title", "High", null,
				POMPOM.STATUS_ONGOING, null, addedStartDate_3, addedEndDate_3);
		Item addedTask_3 = taskList.get(2);
		assertTrue(testIsSameItem(addedTask_3, expectedAddedTask_3));
		Item expectedAddedTask_4 = new Item(null, POMPOM.LABEL_EVENT, "Test 4",
				null, null, POMPOM.STATUS_COMPLETED, "test", addedStartDate_4,
				addedEndDate_4);
		Item addedTask_4 = taskList.get(3);
		assertTrue(testIsSameItem(expectedAddedTask_4, addedTask_4));

	}

	/**
	 * Test all the bad commands of task and whether it returns the correct
	 * error message or not. This is the same type of test with event bad
	 * commands but to be complete we got to do with the task method as well
	 */
	@Test
	public void testAddTaskBadCommands() {
		int initialSize = taskList.size();
		String badUserCommand_1 = "add";  
		String badReturnMsg_1 = pompom.execute(badUserCommand_1);

		assertEquals(String.format(AddParser.MESSAGE_EMPTY_ERROR, ""),
				badReturnMsg_1);
		assertEquals(initialSize, taskList.size());

		String badUserCommand_2 = "add do this f:asdf";
		String badReturnMsg_2 = pompom.execute(badUserCommand_2);

		assertEquals(String.format(AddParser.MESSAGE_DATE_ERROR, "asdf"),
				badReturnMsg_2);
		assertEquals(initialSize, taskList.size());

		String badUserCommand_4 = "add do this f:today e:tomorrow r:asdf";
		String badReturnMsg_4 = pompom.execute(badUserCommand_4);

		assertEquals(String.format(AddParser.MESSAGE_RECURRING_ERROR, "asdf"),
				badReturnMsg_4);
		assertEquals(initialSize, taskList.size());

		String badUserCommand_5 = "add do this f:today e:tomorrow r:daily until 01 may 2017 x:asdf";
		String badReturnMsg_5 = pompom.execute(badUserCommand_5);

		assertEquals(String.format(AddParser.MESSAGE_EXCLUSION_ERROR, "asdf"),
				badReturnMsg_5);
		assertEquals(initialSize, taskList.size());

		String badUserCommand_6 = "add do this p:asdf";
		String badReturnMsg_6 = pompom.execute(badUserCommand_6);

		assertEquals(String.format(AddParser.MESSAGE_PRIORITY_ERROR, "asdf"),
				badReturnMsg_6);
		assertEquals(initialSize, taskList.size());

		String badUserCommand_7 = "add do this e:today f:tomorrow";
		String badReturnMsg_7 = pompom.execute(badUserCommand_7);

		assertEquals(String.format(AddParser.MESSAGE_END_BEFORE_FROM, "asdf"),
				badReturnMsg_7);
		assertEquals(initialSize, taskList.size());

		String badUserCommand_8 = "add do this r:daily until 01 may 2017";
		String badReturnMsg_8 = pompom.execute(badUserCommand_8);

		assertEquals(String.format(AddParser.MESSAGE_START_DATE_SPECIFIED, ""),
				badReturnMsg_8);
		assertEquals(initialSize, taskList.size());

	}

	/**
	 * Test deleting a normal task and whether it handles invalid delete id
	 * correctly or not
	 */
	@Test
	public void testDeleteById() {

		// Make sure subsequent tests start from clean slate
		taskList.clear();

		String userCommand_1 = "add do project1 f:april 1";
		String userCommand_2 = "add do project2 f:april 2";
		String userCommand_3 = "add do project3 f:april 3";

		String returnMsg_1 = pompom.execute(userCommand_1);
		String returnMsg_2 = pompom.execute(userCommand_2);
		String returnMsg_3 = pompom.execute(userCommand_3);

		// check if the add commands returns the right status message
		assertEquals("Task added", returnMsg_1);
		assertEquals("Task added", returnMsg_2);
		assertEquals("Task added", returnMsg_3);

		long id = taskList.get(1).getId();
		String delCommand = "delete " + id;
		pompom.execute(delCommand);

		// check if the correct task got deleted
		assertEquals(2, taskList.size());
		assertEquals("do project1", taskList.get(0).getTitle());
		assertEquals("do project3", taskList.get(1).getTitle());

		// Test invalid delete
		String delFail = "delete " + "99999";
		String delFailReturnMsg = pompom.execute(delFail);

		assertEquals(String.format(DelCommand.MESSAGE_ID_INVALID, "99999"),
				delFailReturnMsg);
	}

	/**
	 * Test undo a recurring add and deleterecur we test this by checking the
	 * tasklist size as we assume task is added correctly.
	 */
	@Test
	public void testDeleteOnRecurringAndUndo() {

		// Make sure subsequent tests start from clean slate
		taskList.clear();
		// 20 days
		String userCommand_1 = "add test f:04/11/2016 e:tomorrow p:h r:daily until 30 apr 2016";
		String returnMsg_1 = pompom.execute(userCommand_1);

		// check if the add commands returns the right status message
		assertEquals(AddRecurringCommand.MESSAGE_RECURRING, returnMsg_1);
		assertEquals(20, taskList.size());
		String undoCommnad_1 = "undo";
		String undoReturnMsg_1 = pompom.execute(undoCommnad_1);

		assertEquals(UndoCommand.MESSAGE_UNDO, undoReturnMsg_1);
		assertEquals(0, taskList.size());

		// Then add back the same things
		returnMsg_1 = pompom.execute(userCommand_1);
		assertEquals(AddRecurringCommand.MESSAGE_RECURRING, returnMsg_1);

		// Delete a middle task first
		long id_1 = taskList.get(1).getId();
		String stringId_1 = Long.toString(id_1);
		String delCommand = "delete " + id_1;
		String deleteReturnMsg = pompom.execute(delCommand);
		assertEquals(String.format(DelCommand.MESSAGE_TASK_DELETED, stringId_1,
				"Task"), deleteReturnMsg);
		assertEquals(19, taskList.size());

		// Delete recurring
		long id = taskList.get(2).getId();
		String delRecurCommand = "deleterecur " + id;
		String deleteRecurReturnMsg = pompom.execute(delRecurCommand);

		assertEquals(DelRecurringCommand.MESSAGE_DELETE_RECURRING,
				deleteRecurReturnMsg);
		// check if the delete command returns the right status message

		// check if the correct task got deleted
		assertEquals(0, taskList.size());

		// Try undo
		String undoCommand_2 = "undo";
		String undoReturnMsg_2 = pompom.execute(undoCommand_2);

		// check if the correct task got deleted
		assertEquals(UndoCommand.MESSAGE_UNDO, undoReturnMsg_2);
		assertEquals(19, taskList.size());
	}

	/**
	 * Simple test for editing title
	 */
	@Test
	public void testEditTitle() {

		// Make sure subsequent tests start from clean slate
		taskList.clear();

		String userCommand_1 = "add do project1 april 1";
		String userCommand_2 = "add do project2 april 2";
		String userCommand_3 = "add do project3 april 3";

		String returnMsg_1 = pompom.execute(userCommand_1);
		String returnMsg_2 = pompom.execute(userCommand_2);
		String returnMsg_3 = pompom.execute(userCommand_3);

		// check if the add commands returns the right status message
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Task"),
				returnMsg_1);
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Task"),
				returnMsg_2);
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Task"),
				returnMsg_3);

		long id_1 = taskList.get(0).getId();
		long id_2 = taskList.get(1).getId();
		long id_3 = taskList.get(2).getId();

		String editCommand_1 = "edit " + id_1 + " title do project4";
		String editCommand_2 = "edit " + id_2 + " title do project5";
		String editCommand_3 = "edit " + id_3 + " title do project6";

		String returnMsg_4 = pompom.execute(editCommand_1);
		String returnMsg_5 = pompom.execute(editCommand_2);
		String returnMsg_6 = pompom.execute(editCommand_3);

		// check if the edit command returns the right status message
		assertEquals(id_1 + " was successfully edited", returnMsg_4);
		assertEquals(id_2 + " was successfully edited", returnMsg_5);
		assertEquals(id_3 + " was successfully edited", returnMsg_6);

		// check if the correct task got deleted
		assertEquals(3, taskList.size());
		assertEquals("do project4", taskList.get(0).getTitle());
		assertEquals("do project5", taskList.get(1).getTitle());
		assertEquals("do project6", taskList.get(2).getTitle());

	}

	/**
	 * Simple test for editing date
	 */
	@Test
	public void testEditDate() {

		// Make sure subsequent tests start from clean slate
		taskList.clear();

		String userCommand_1 = "add do project1 f:april 1";
		String userCommand_2 = "add do project2 f:april 2";
		String userCommand_3 = "add do project3 f:april 3";

		String returnMsg_1 = pompom.execute(userCommand_1);
		String returnMsg_2 = pompom.execute(userCommand_2);
		String returnMsg_3 = pompom.execute(userCommand_3);

		// check if the add commands returns the right status message
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Task"),
				returnMsg_1);
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Task"),
				returnMsg_2);
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Task"),
				returnMsg_3);

		long id_1 = taskList.get(0).getId();
		long id_2 = taskList.get(1).getId();
		long id_3 = taskList.get(2).getId();

		String stringId_1 = Long.toString(id_1);
		String stringId_3 = Long.toString(id_3);

		String editCommand_1 = "edit " + id_1 + " start date today";
		// This command should fail invalid end date
		String editCommand_2 = "edit " + id_2 + " end date 01/11/2013";
		String editCommand_3 = "edit " + id_3 + " end date next year";

		String returnMsg_4 = pompom.execute(editCommand_1);
		String returnMsg_5 = pompom.execute(editCommand_2);
		String returnMsg_6 = pompom.execute(editCommand_3);

		// check if the edit command returns the right status message
		assertEquals(
				String.format(EditCommand.MESSAGE_TASK_EDITED, stringId_1),
				returnMsg_4);
		assertEquals(EditCommand.MESSAGE_DATE_CHANGE_ERROR, returnMsg_5);
		assertEquals(
				String.format(EditCommand.MESSAGE_TASK_EDITED, stringId_3),
				returnMsg_6);

		// Check if list still contains 3 times
		assertEquals(3, taskList.size());
		SimpleDateFormat sdf = new SimpleDateFormat("dd MMM yyyy HH:mm");
		assertEquals(sdf.format(parseFromDate("today")), taskList.get(0)
				.getSd());
		assertEquals(sdf.format(parseFromDate("april 2")), taskList.get(1)
				.getSd());
		assertEquals(sdf.format(parseFromDate("next year")), taskList.get(2)
				.getEd());

	}

	/**
	 * Simple test for editing label
	 */
	@Test
	public void testEditLabel() {

		// Make sure subsequent tests start from clean slate
		taskList.clear();

		String userCommand_1 = "add do project1 april 1 l:work";
		String userCommand_2 = "add do project2 april 2 l:work";
		String userCommand_3 = "add do project3 april 3 l:work";

		String returnMsg_1 = pompom.execute(userCommand_1);
		String returnMsg_2 = pompom.execute(userCommand_2);
		String returnMsg_3 = pompom.execute(userCommand_3);

		// check if the add commands returns the right status message
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Task"),
				returnMsg_1);
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Task"),
				returnMsg_2);
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Task"),
				returnMsg_3);

		long id_1 = taskList.get(0).getId();
		long id_2 = taskList.get(1).getId();
		long id_3 = taskList.get(2).getId();

		String editCommand_1 = "edit " + id_1 + " label do work";
		String editCommand_2 = "edit " + id_2 + " label more work";
		String editCommand_3 = "edit " + id_3 + " label even more work";

		String returnMsg_4 = pompom.execute(editCommand_1);
		String returnMsg_5 = pompom.execute(editCommand_2);
		String returnMsg_6 = pompom.execute(editCommand_3);

		// check if the edit command returns the right status message
		assertEquals(id_1 + " was successfully edited", returnMsg_4);
		assertEquals(id_2 + " was successfully edited", returnMsg_5);
		assertEquals(id_3 + " was successfully edited", returnMsg_6);

		// check if the correct task got deleted
		assertEquals(3, taskList.size());
		assertEquals("do work", taskList.get(0).getLabel());
		assertEquals("more work", taskList.get(1).getLabel());
		assertEquals("even more work", taskList.get(2).getLabel());

	}

	/**
	 * Simple test on editing priority
	 */
	@Test
	public void testEditPriority() {

		// Make sure subsequent tests start from clean slate
		taskList.clear();

		String userCommand_1 = "add do project1 april 1 l:work";
		String userCommand_2 = "add do project2 april 2 l:work";
		String userCommand_3 = "add do project3 april 3 l:work";

		String returnMsg_1 = pompom.execute(userCommand_1);
		String returnMsg_2 = pompom.execute(userCommand_2);
		String returnMsg_3 = pompom.execute(userCommand_3);

		// check if the add commands returns the right status message
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Task"),
				returnMsg_1);
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Task"),
				returnMsg_2);
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Task"),
				returnMsg_3);

		long id_1 = taskList.get(0).getId();
		long id_2 = taskList.get(1).getId();
		long id_3 = taskList.get(2).getId();

		String editCommand_1 = "edit " + id_1 + " priority low";
		String editCommand_2 = "edit " + id_2 + " priority medium";
		String editCommand_3 = "edit " + id_3 + " priority high";

		String returnMsg_4 = pompom.execute(editCommand_1);
		String returnMsg_5 = pompom.execute(editCommand_2);
		String returnMsg_6 = pompom.execute(editCommand_3);

		// check if the edit command returns the right status message
		assertEquals(id_1 + " was successfully edited", returnMsg_4);
		assertEquals(id_2 + " was successfully edited", returnMsg_5);
		assertEquals(id_3 + " was successfully edited", returnMsg_6);

		// check if the correct task got deleted
		assertEquals(3, taskList.size());
		assertEquals("Low", taskList.get(0).getPriority());
		assertEquals("Medium", taskList.get(1).getPriority());
		assertEquals("High", taskList.get(2).getPriority());

	}

	/**
	 * Simple test on edit recurring
	 */
	@Test
	public void testEditRecurring() {
		taskList.clear();
		String userCommand_1 = "add test f:04/11/2016 e:tomorrow l:Sweet p:h r:daily until 30 apr 2016";
		String returnMsg_1 = pompom.execute(userCommand_1);

		// check if the add commands returns the right status message
		assertEquals(AddRecurringCommand.MESSAGE_RECURRING, returnMsg_1);
		long id = taskList.get(0).getId();
		String userCommand_2 = "editrecur " + id + " title new testing";
		String returnMsg_2 = pompom.execute(userCommand_2);
		assertEquals(EditRecurringCommand.MESSAGE_EDIT_RECURRING, returnMsg_2);

		for (Item item : taskList) {
			assertEquals(item.getTitle(), "new testing");
		}

		String userCommand_3 = "editrecur " + id + " priority high";
		String returnMsg_3 = pompom.execute(userCommand_3);
		assertEquals(EditRecurringCommand.MESSAGE_EDIT_RECURRING, returnMsg_3);

		for (Item item : taskList) {
			assertEquals(item.getPriority(), "High");
		}

		String userCommand_4 = "editrecur " + id + " label Test Label";
		String returnMsg_4 = pompom.execute(userCommand_4);
		assertEquals(EditRecurringCommand.MESSAGE_EDIT_RECURRING, returnMsg_4);

		for (Item item : taskList) { 
			assertEquals(item.getLabel(), "Test Label");
		}
		// Test does undo returns original Label a not
		String undoCommand = "undo";
		String undoReturnMsg = pompom.execute(undoCommand);

		assertEquals(UndoCommand.MESSAGE_UNDO, undoReturnMsg);
		for (Item item : taskList) {
			assertEquals(item.getLabel(), "Sweet");
		}
	}

	/**
	 * Simple test on search. Search allows for error. For more information on
	 * the search algorithm Please view search command class.
	 */
	@Test
	public void testSearch() {

		// Make sure subsequent tests start from clean slate
		taskList.clear();

		String userCommand_1 = "add do project1 april 1 l:work";
		String userCommand_2 = "add do project2 april 2 l:work";
		String userCommand_3 = "add asdas april 3 l:work";

		String returnMsg_1 = pompom.execute(userCommand_1);
		String returnMsg_2 = pompom.execute(userCommand_2);
		String returnMsg_3 = pompom.execute(userCommand_3);

		// check if the add commands returns the right status message
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Task"),
				returnMsg_1);
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Task"),
				returnMsg_2);
		assertEquals(String.format(AddCommand.MESSAGE_TASK_ADDED, "Task"),
				returnMsg_3);

		String searchCommand_1 = "search do";
		String searchCommand_2 = "search project";
		String searchCommand_3 = "search asdas";

		String returnMsg_4 = pompom.execute(searchCommand_1);
		assertEquals("Search resulted in 2 result(s).", returnMsg_4);
		assertEquals(2, POMPOM.getSearchList().size());

		String returnMsg_5 = pompom.execute(searchCommand_2);
		assertEquals("Search resulted in 2 result(s).", returnMsg_5);
		assertEquals(2, POMPOM.getSearchList().size());

		String returnMsg_6 = pompom.execute(searchCommand_3);
		assertEquals("Search resulted in 1 result(s).", returnMsg_6);
		assertEquals(1, POMPOM.getSearchList().size());

	}

	/**
	 * Reset to the state before test was conducted
	 * 
	 * @throws IOException
	 */
	@After
	public void resetToOriginal() throws IOException {
		POMPOM.saveSettings(Storage.DEFAULT_STORAGE_FILE_PATH);
	}

}
```
###### src\utils\CheckBoxCellFactory.java
``` java
 *
 */
public class CheckBoxCellFactory implements Callback {
    @Override
    public TableCell call(Object param) {
        CheckBoxTableCell<Item,Boolean> checkBoxCell = new CheckBoxTableCell();
        
        return checkBoxCell;
    }
}
```
###### src\utils\FileHandler.java
``` java
 *
 */
public class FileHandler {
	/**
	 * This method rewrites the file with the given text.
	 * 
	 * 
	 * @param file
	 * @param text
	 * @throws IOException
	 */
	public static void writeStringToFile(File file, String text)
			throws IOException {
		FileWriter out = new FileWriter(file);
		out.write(text);
		out.close();
	}

	/**
	 * This method get string from the file given the file path
	 * 
	 * @param path
	 * @return
	 * @throws IOException
	 */
	public static String getStringFromFile(String path) {
		byte[] encoded = null;
		try {
			Paths.get(path);
			encoded = Files.readAllBytes(Paths.get(path));
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return new String(encoded, StandardCharsets.UTF_8);
	}
}
```
###### src\utils\Item.java
``` java
 */
// implements Comparator<Item>
public class Item {
	private Long id;
	private String title;
	private String type;
	private String priority;
	private String description;
	private String status;
	private String label;
	private Date startDate;
	private Date endDate;
	private String sd;

	private String ed;
	private Boolean checkBox;

	private boolean isRecurring;
	private Long prevId;
	private Long nextId;

	public Item(Long id, String type, String title, String priority,
			String description, String status, String label, Date startDate,
			Date endDate) {
		super();
		this.id = id;
		this.type = type;
		this.title = title; 
		this.priority = priority;
		this.description = description;
		this.status = status;
		this.label = label;
		this.startDate = startDate;
		this.endDate = endDate;
		SimpleDateFormat sdf = new SimpleDateFormat("dd MMM yyyy HH:mm");
		if (this.startDate != null) {
			setSd(sdf.format(startDate));
		}
		if (this.endDate != null) {
			setEd(sdf.format(endDate));
		}

	}

	public Item() {

	}

	private SimpleBooleanProperty checked = new SimpleBooleanProperty(false);

	public SimpleBooleanProperty checkedProperty() {
		return this.checked;
	}

	public Boolean getChecked() {
		return this.checkedProperty().get();
	}

	public void setChecked(final Boolean checked) {
		this.checkedProperty().set(checked);
	}

	public Long getId() {
		return id;
	}

	public void setId(Long i) {
		this.id = i;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getType() {
		return type;
	}

	public void setType(String type) {
		this.type = type;
	}

	public String getPriority() {
		return priority;
	}

	public void setPriority(String priority) {
		this.priority = WordUtils.capitalize(priority);
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public String getLabel() {
		return label;
	}

	public void setLabel(String label) {
		this.label = label;
	}

	public Date getStartDate() {
		return startDate;
	}

	public void setStartDate(Date startDate) {
		if (startDate == null) {
			setSd(null);
			this.startDate = startDate;
			return;
		}
		SimpleDateFormat sdf = new SimpleDateFormat("dd MMM yyyy HH:mm");
		setSd(sdf.format(startDate));
		this.startDate = startDate;
	}

	public String getSd() {
		return sd;
	}

	public void setSd(String sd) {
		this.sd = sd;
	}

	public String getEd() {
		return ed;
	}

	public void setEd(String ed) {
		this.ed = ed;
	}

	public Date getEndDate() {
		return endDate;
	}

	public void setEndDate(Date endDate) {
		if (endDate == null) {
			setEd(null);
			this.endDate = endDate;
			return;
		}
		SimpleDateFormat sdf = new SimpleDateFormat("dd MMM yyyy HH:mm");
		setEd(sdf.format(endDate));
		this.endDate = endDate;
	}

	public Boolean getCheckBox() {
		return checkBox;
	}

	public void setCheckBox(Boolean checkBox) {
		this.checkBox = checkBox;
	}

	public boolean isRecurring() {
		return isRecurring;
	}

	public void setRecurring(boolean isRecurring) {
		this.isRecurring = isRecurring;
	}

	public Long getPrevId() {
		return prevId;
	}

	public void setPrevId(Long prevId) {
		this.prevId = prevId;
	}

	public Long getNextId() {
		return nextId;
	}

	public void setNextId(Long nextId) {
		this.nextId = nextId;
	}

	// Debugging Method
	// public void printInfo() {
	// System.out.println("");
	// System.out.println("Task ID: " + getId());
	// System.out.println("Type: " + getType());
	// System.out.println("Title: " + getTitle());
	// System.out.println("Priority: " + getPriority());
	// System.out.println("Description: " + getDescription());
	// System.out.println("Status: " + getStatus());
	// System.out.println("Label: " + getLabel());
	// System.out.println("StartDate: " + getStartDate());
	// System.out.println("EndDate: " + getEndDate());
	// System.out.println("");
	// }

}
```
###### src\utils\ItemAdapter.java
``` java
 */

public class ItemAdapter extends TypeAdapter<UserItemList> {

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.google.gson.TypeAdapter#read(com.google.gson.stream.JsonReader)
	 */
	@Override
	public UserItemList read(JsonReader in) throws IOException {
		final UserItemList userTaskList = new UserItemList();
		SimpleDateFormat formatter = new SimpleDateFormat(
				"EEE MMM d HH:mm:ss z yyyy");
		in.beginObject();
		while (in.hasNext()) {
			switch (in.nextName()) {
			case "Username":
				userTaskList.setUserName(in.nextString());
				break;
			case "IdCounter":
				userTaskList.setIdCounter(in.nextLong());
				break;
			case "TaskList":
				in.beginArray();
				ArrayList<Item> taskArrayList = new ArrayList<Item>();
				while (in.hasNext()) {
					in.beginObject();
					final Item task = new Item();
					while (in.hasNext()) {
						switch (in.nextName()) {
						case "Id":
							task.setId(in.nextLong());
							break;
						case "Type":
							task.setType(in.nextString());
							break;
						case "Title":
							task.setTitle(in.nextString());
							break;
						case "Priority":
							task.setPriority(in.nextString());
							break;
						case "Description":
							task.setDescription(in.nextString());
							break;
						case "Label":
							task.setLabel(in.nextString());
							break;
						case "Status":
							task.setStatus(in.nextString());
							break;
						case "IsRecurring":
							task.setRecurring(in.nextBoolean());
							break;
						case "PrevId":
							task.setPrevId(in.nextLong());
							break;
						case "NextId":
							task.setNextId(in.nextLong());
							break;

						case "StartDate":
							try {
								task.setStartDate(formatter.parse(in
										.nextString()));
							} catch (ParseException e) {
								e.printStackTrace();
							}
							break;
						case "EndDate":
							try {
								task.setEndDate(formatter.parse(in.nextString()));
							} catch (ParseException e) {
								e.printStackTrace();
							}

							break;

						}
					}
					taskArrayList.add(task);
					in.endObject();
				}
				userTaskList.setTaskArray(taskArrayList);
				in.endArray();
				break;
			}
		}
		in.endObject();

		return userTaskList;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.google.gson.TypeAdapter#write(com.google.gson.stream.JsonWriter,
	 * java.lang.Object)
	 */
	@Override
	public void write(JsonWriter out, UserItemList userTaskList)
			throws IOException {
		out.beginObject();
		out.name("Username").value(userTaskList.getUserName());
		out.name("IdCounter").value(userTaskList.getIdCounter());
		out.name("TaskList").beginArray();

		if (userTaskList.getTaskArray() != null) {
			ArrayList<Item> taskList = userTaskList.getTaskArray();

			for (final Item task : taskList) {
				out.beginObject();
				out.name("Id").value(task.getId());
				out.name("Type").value(task.getType());
				out.name("Title").value(task.getTitle());
				out.name("Priority").value(task.getPriority());
				out.name("Description").value(task.getDescription());
				out.name("Label").value(task.getLabel());
				out.name("Status").value(task.getStatus());

				if (task.getStartDate() != null) {
					out.name("StartDate").value(task.getStartDate().toString());
				}
				if (task.getEndDate() != null) {
					out.name("EndDate").value(task.getEndDate().toString());
				}
				out.name("IsRecurring").value(task.isRecurring());
				out.name("PrevId").value(task.getPrevId());
				out.name("NextId").value(task.getNextId());
				out.endObject();

			}
			out.endArray();
			out.endObject();

		}
	}
}
```
###### src\utils\ListClassifier.java
``` java
 * 
 */
public class ListClassifier {

	
	/**
	 * This method check with input date and determine whether the dates have the same day
	 * @param input
	 * @param sd
	 * @return
	 */
	private static boolean checkIsToday(Date input, Date sd) {
		if(sd == null){
			return false;
		}
		Calendar cal1 = Calendar.getInstance();
		Calendar cal2 = Calendar.getInstance();
		cal1.setTime(input);
		cal2.setTime(sd);
		boolean sameDay = cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
		                  cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR);
			return sameDay;
	}

	/**
	 * This method counts the number of task which is today
	 * @param lst
	 * @return
	 */
	public static String getTodayTask(ArrayList<Item> lst){
		Date currentDate = new Date();
		int counter = 0;
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);
			if(!currentTask.getType().toLowerCase().equals("task")){
				continue;
			}
			if(currentTask.getStatus().equals("ongoing")){
				counter++;
				continue;
			}
			boolean todayCheck = checkIsToday(currentDate, currentTask.getStartDate());
			// Remove this line after proper init of task and events
			if (todayCheck){
				counter++;
			}
			
		}
		return Integer.toString(counter);
	}

	/**
	 * This method count the number of events today
	 * @param lst
	 * @return
	 */
	public static String getTodayEvent(ArrayList<Item> lst) {
		Date currentDate = new Date();
		int counter = 0;
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);
			if(!currentTask.getType().toLowerCase().equals("event")){
				continue;
			}
			if(currentTask.getStatus().equals("ongoing")){
				counter++;
				continue;
			}
			boolean todayCheck = checkIsToday(currentDate, currentTask.getStartDate());
			// Remove this line after proper init of task and events
			if (todayCheck){
				counter++;
			}
			
		}
		return Integer.toString(counter);

	}

	/**
	 * This method counts the number of overview task
	 * @param lst
	 * @return
	 */
	public static String getOverdueTask(ArrayList<Item> lst) {
		int counter = 0;
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);
			if(currentTask.getType().toLowerCase().equals("task")
					&& currentTask.getStatus().equals("Overdue")){
				counter++;
			}
		
			
		}
		return Integer.toString(counter);

	}
	/**
	 * This method filter the given list and return the item list which contains
	 * task only or empty list
	 * 
	 * @param lst
	 * @return
	 */
	public static ArrayList<Item> getTaskList(ArrayList<Item> lst) {
		ArrayList<Item> result = new ArrayList<Item>();
		
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);
			// Remove this line after proper init of task and event
			if (currentTask.getType() == null)
				continue;
			if (currentTask.getType().toLowerCase().equals("task")
					&& !currentTask.getStatus().equals(POMPOM.STATUS_COMPLETED)) {
				result.add(currentTask);
			}
		}
		return result;
	}

	//
	/**
	 * This method filter the given list and return the item list which contains
	 * completed task only or empty list
	 * 
	 * @param lst
	 * @return
	 */
	public static ArrayList<Item> getDoneTaskList(ArrayList<Item> lst) {
		ArrayList<Item> result = new ArrayList<Item>();
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);
			// Remove this line after proper init of task and events

			if (currentTask.getType() == null)
				continue;
			if (currentTask.getType().toLowerCase().equals("task")
					&& currentTask.getStatus().toLowerCase()
							.equals("completed")) {
				result.add(currentTask);
			}
		}
		return result;
	}

	//
	/**
	 * This method filter the given list and return the item list which contains
	 * event only or empty list
	 * 
	 * @param lst
	 * @return
	 */
	public static ArrayList<Item> getEventList(ArrayList<Item> lst) {
		ArrayList<Item> result = new ArrayList<Item>();
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);
			if (currentTask.getType() == null)
				continue;
			if (currentTask.getType().equals("Event")
					&& !currentTask.getStatus().equals(POMPOM.STATUS_COMPLETED)) {
				result.add(currentTask);
			}
		}
		return result;
	}

	/**
	 * This method filter the given list and return the item list which contains
	 * completed events only or empty list
	 * 
	 * @param lst
	 * @return
	 */
	public static ArrayList<Item> getDoneEventList(ArrayList<Item> lst) {
		ArrayList<Item> result = new ArrayList<Item>();
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);
			if (currentTask.getType() == null) {
				continue;
			}
			if (currentTask.getType().equals("Event")
					&& currentTask.getStatus().equals(POMPOM.STATUS_COMPLETED)) {
				result.add(currentTask);
			}
		}
		return result;
	}

	/**
	 * This method returns a list with the filtered priority.
	 * @param lst
	 * @param priority
	 * @return
	 */
	public static ObservableList<Item> getSpecifiedPrirorirty(ObservableList<Item> lst,
			String priority) {
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);
			
			if (currentTask.getPriority() == null) {
				i--;
				lst.remove(currentTask);
				continue;
			}
			
			if (!currentTask.getPriority().toLowerCase().equals(priority)) {
				i--;
				lst.remove(currentTask);
			}
		}
		return lst;

	}


}
```
###### src\utils\Settings.java
``` java
 *
 */
public class Settings {
	private String storagePath;
	private String backgroundColour;
	private String returnMsgColour;
	private String inputTxtColour;

	public Settings(String storagePath, String backgroundColour,
			String returnMsgColour, String inputTxtColour) {
		super();
		this.storagePath = storagePath;
		this.backgroundColour = backgroundColour;
		this.returnMsgColour = returnMsgColour;
		this.inputTxtColour = inputTxtColour;
	}

	public Settings() {

	}

	public String getReturnMsgColour() {
		return returnMsgColour;
	}

	public void setReturnMsgColour(String returnMsgColour) {
		this.returnMsgColour = returnMsgColour;
	}

	public String getInputTxtColour() {
		return inputTxtColour;
	}

	public void setInputTxtColour(String inputTxtColour) {
		this.inputTxtColour = inputTxtColour;
	}

	public String getStoragePath() {
		return storagePath;
	}

	public void setStoragePath(String storagePath) {
		this.storagePath = storagePath;
	}

	public String getBackgroundColour() {
		return backgroundColour;
	}

	public void setBackgroundColour(String backgroundColour) {
		this.backgroundColour = backgroundColour;
	}

}
```
###### src\utils\SettingsAdapter.java
``` java
 * 
 */
public class SettingsAdapter extends TypeAdapter<Settings> {

	@Override
	public Settings read(JsonReader in) throws IOException {
		Settings settings = new Settings();
		in.beginObject();
		while (in.hasNext()) {
			switch (in.nextName()) {
			case "storagePath":
				settings.setStoragePath(in.nextString());
				break;
			case "backgroundColour":
				settings.setBackgroundColour(in.nextString());
				break;
			case "displayMsgColour":
				settings.setReturnMsgColour(in.nextString());
				break;
			case "inputTxtColour":
				settings.setInputTxtColour(in.nextString());
				break;
			}
		}
		in.endObject();
		return settings;
	}

	@Override
	public void write(JsonWriter out, Settings settings) throws IOException {
		out.beginObject();

		out.name("storagePath").value(settings.getStoragePath());
		out.name("backgroundColour").value(settings.getBackgroundColour());
		out.name("displayMsgColour").value(settings.getReturnMsgColour());
		out.name("inputTxtColour").value(settings.getInputTxtColour());

		out.endObject();
		out.close();
	}

}
```
###### src\utils\UserItemList.java
``` java
 */
public class UserItemList {
	private String userName;
	private long IdCounter;
	private ArrayList<Item> taskArray;

	public UserItemList(String userName, ArrayList<Item> taskArray) {
		this.userName = userName;
		this.taskArray = taskArray;
	}

	public UserItemList() {
	}

	public String getUserName() {
		return userName;
	}

	public void setUserName(String userName) {
		this.userName = userName;
	}

	public ArrayList<Item> getTaskArray() {
		return taskArray;
	}

	public void setTaskArray(ArrayList<Item> taskArray) {
		this.taskArray = taskArray;
	}

	public long getIdCounter() {
		return IdCounter;
	}

	public void setIdCounter(long idCounter) {
		IdCounter = idCounter;
	}

	// Debugging Method.
	// public void printInfo() {
	// if (userName == null)
	// System.out.println("User not set");
	// if (getTaskArray() == null){
	// System.out.println("No Task");
	// return;
	// }
	//
	// System.out.println("UserName: " + userName);
	// for (int i = 0; i < taskArray.size(); i++) {
	// taskArray.get(i).printInfo();
	//
	// }
	//
	// }

}
```
