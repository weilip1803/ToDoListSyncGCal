# A0121528M
###### src\command\AddCommand.java
``` java
 */
public class AddCommand extends Command {

	/** Messaging **/
	public static final String MESSAGE_TASK_ADDED = "%s added";

	/** Command parameters **/
	private Item task;
	private boolean isUndo;
	
	/**
	 * Constructor for a normal add command
	 * 
	 * @param type
	 * @param title
	 * @param description
	 * @param priority
	 * @param status
	 * @param label
	 * @param startDate
	 * @param endDate
	 */
	public AddCommand(String type, String title, String description, String priority, String status, String label,
			Date startDate, Date endDate) {

		task = new Item();
		isUndo = false;
		assertNotNull(title);

		Long id = POMPOM.getStorage().getIdCounter();
		task.setId(id);
		task.setType(type);
		task.setTitle(title);
		task.setDescription(description);
		task.setPriority(priority);
		task.setStatus(status);
		task.setLabel(label);
		task.setStartDate(startDate);
		task.setEndDate(endDate);
		task.setRecurring(false);

		logger.log(Level.INFO, "AddCommand initialized");
	}

	/**
	 * Constructor for a recurring add command
	 * 
	 * @param type
	 * @param title
	 * @param description
	 * @param priority
	 * @param status
	 * @param label
	 * @param startDate
	 * @param endDate
	 * @param isRecurring
	 */
	public AddCommand(String type, String title, String description, String priority, String status, String label,
			Date startDate, Date endDate, boolean isRecurring) {

		task = new Item();
		isUndo = false;
		assertNotNull(title);

		Long id = POMPOM.getStorage().getIdCounter();
		task.setId(id);
		task.setType(type);
		task.setTitle(title);
		task.setDescription(description);
		task.setPriority(priority);
		task.setStatus(status);
		task.setLabel(label);
		task.setStartDate(startDate);
		task.setEndDate(endDate);
		task.setRecurring(true);

		logger.log(Level.INFO, "Recurring AddCommand initialized");
	}

	/**
	 * Constructor for an undo add command
	 * 
	 * @param id
	 * @param type
	 * @param title
	 * @param description
	 * @param priority
	 * @param status
	 * @param label
	 * @param startDate
	 * @param endDate
	 * @param isRecurring
	 * @param prevId
	 * @param nextId
	 */
	public AddCommand(Long id, String type, String title, String description, String priority, String status,
			String label, Date startDate, Date endDate, boolean isRecurring, Long prevId, Long nextId) {

		task = new Item();
		isUndo = true;
		assertNotNull(title);

		task.setId(id);
		task.setType(type);
		task.setTitle(title);
		task.setDescription(description);
		task.setPriority(priority);
		task.setStatus(status);
		task.setLabel(label);
		task.setStartDate(startDate);
		task.setEndDate(endDate);
		task.setRecurring(isRecurring);
		task.setPrevId(prevId);
		task.setNextId(nextId);

		logger.log(Level.INFO, "Counter action AddCommand initialized");
	}

	/**
	 * Carries out the actual action of add task into taskList
	 */
	private void storeTask() {
		POMPOM.getStorage().getTaskList().add(task);
	}

	/**
	 * Creates the reverse action for undo. For AddCommand, the reverse would be
	 * DelCommand.
	 * 
	 * @return the reverse command
	 */
	private Command createCounterAction() {
		DelCommand counterAction = new DelCommand(task.getId(), true);
		return counterAction;
	}

	/**
	 * Adds the reverse command into the undo stack
	 */
	private void updateUndoStack() {
		Command counterAction = createCounterAction();
		POMPOM.getUndoStack().push(counterAction);
	}

	/**
	 * Sets the pointer of the recurring tasks. Like a linked list, when the
	 * middle element is deleted, the pointers of the previous node should link
	 * to the next node.
	 * 
	 * Now after deleting, when the task is added back by undo, the reverse
	 * linking process should take place
	 */
	private void setProperPointers() {

		Item currentTask = task;

		Item prevTask = getTask(currentTask.getPrevId());
		prevTask.setNextId(currentTask.getId());

		Item nextTask = getTask(currentTask.getNextId());
		nextTask.setPrevId(currentTask.getId());

	}

	/**
	 * Sets the proper return message to return
	 */
	private void setProperReturnMsg() {

		if (task.getType().equals(POMPOM.LABEL_EVENT)) {
			returnMsg = String.format(MESSAGE_TASK_ADDED, POMPOM.LABEL_EVENT);
		} else {
			returnMsg = String.format(MESSAGE_TASK_ADDED, POMPOM.LABEL_TASK);
		}

	}

	/**
	 * Executes all the actions needed when a add command is invoked
	 * 
	 * @return the appropriate feedback message
	 */
	public String execute() {

		if (!isUndo && !task.isRecurring()) {
			updateUndoStack();
		}

		storeTask();

		if (isUndo && task.isRecurring()) {
			setProperPointers();
		}

		setProperReturnMsg();
		POMPOM.refreshStatus();
		showCorrectTab(task);

		logger.log(Level.INFO, "AddCommand has be executed");
		return returnMsg;
	}

}
```
###### src\command\AddRecurringCommand.java
``` java
 */
public class AddRecurringCommand extends Command {

	/** Messaging **/
	public static final String MESSAGE_RECURRING = "Recurring tasks has been added";

	/** Command Parameters **/
	ArrayList<AddCommand> addList;
	ArrayList<Item> itemList; 
	ArrayList<Item> taskList = getTaskList();
	Long firstId = null, prevId = null, currentId, nextId = null;
	Long[] idList;
	boolean isUndo;

	
	/**
	 * Constructor for AddRecurringCommand object
	 * 
	 * @param addList
	 */
	public AddRecurringCommand(ArrayList<AddCommand> addList) {
		this.addList = addList;
		this.idList = new Long[addList.size()];
		this.isUndo = false;
		
		logger.log(Level.INFO, "AddRecurringCommand initialized");
	}
	
	
	/**
	 * Constructor for an undo AddRecurringCommand object
	 * 
	 * @param itemList
	 * @param isUndo
	 */
	public AddRecurringCommand(ArrayList<Item> itemList, boolean isUndo) {
		this.itemList = itemList;
		this.isUndo = true;
		
		logger.log(Level.INFO, "Counter AddRecurringCommand initialized");
	}
	
	
	/**
	 * Creates the reverse action for undo. 
	 * For AddRecurringCommand, the reverse would be DelRecurringCommand.
	 * 
	 * @return the reverse command
	 */
	private Command createCounterAction() {
		return new DelRecurringCommand(idList);
	}
	
	
	/**
	 * Adds the reverse command into the undo stack
	 */
	private void updateUndoStack() {
		Command counterAction = createCounterAction();
		POMPOM.getUndoStack().push(counterAction);
	} 

	
	/**
	 * Executes all the actions needed when an AddRecurringCommand is invoked
	 * 
	 * @return the appropriate feedback message 
	 */
	public String execute() {

		if (isUndo) {
			
			for (int i = 0; i < itemList.size(); i++) {
				taskList.add(itemList.get(i));
			}
			
			logger.log(Level.INFO, "AddRecurringCommand has been executed");
			returnMsg = MESSAGE_RECURRING;
			POMPOM.refreshStatus();
			showCorrectTab(itemList.get(0));
			
		} else {
			
			for (int i = 0; i < addList.size(); i++) {
				
				addList.get(i).execute();
				Item currentTask = taskList.get(taskList.size() - 1);
				currentId = currentTask.getId();
				
				// Sets the linking pointers
				currentTask.setRecurring(true);
				currentTask.setPrevId(prevId);
				prevId = currentId;
				idList[i] = currentId;

				// Saves the firstId
				if (i == 0) {
					firstId = currentId;
				}
				
				if (i == addList.size() - 1) {
					nextId = firstId;
					getTask(firstId).setPrevId(currentId);
				
				} else {
					nextId = currentId + 1;
				}
				
				currentTask.setNextId(nextId);
				
			}
			
			updateUndoStack();
			POMPOM.refreshStatus();
			showCorrectTab(getTask(firstId));
			logger.log(Level.INFO, "AddRecurringCommand has been executed");
			returnMsg = MESSAGE_RECURRING;
		}
		
		return returnMsg;
	}

}
```
###### src\command\Command.java
``` java
 */
public abstract class Command {

	/** Messaging **/
	protected String returnMsg = "";

	public static Logger logger = Logger.getLogger("Command");

	public Command() {

	} 

	/**
	 * Method to get the item with the specified taskId. 
	 * Method is shared among all commands.
	 * 
	 * @param taskId
	 * @return the item with the specified id
	 */
	protected Item getTask(Long taskId) {
		ArrayList<Item> taskList = getTaskList();
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getId().equals(taskId)) {
				return taskList.get(i);
			}
		}
		return null;
	}

	/**
	 * Method to get the list of all stored items. 
	 * Method is shared among all commands.
	 * 
	 * @return the array list of all stored items
	 */
	protected ArrayList<Item> getTaskList() {
		return POMPOM.getStorage().getTaskList();
	}

	/**
	 * Method to check the existence an item with the specified id. 
	 * Method is shared among all commands.
	 * 
	 * @param taskId
	 * @return boolean of whether id exists
	 */
	protected boolean checkExists(Long taskId) {

		Item toDelete = null;
		try {
			toDelete = getTask(taskId);
		} catch (IndexOutOfBoundsException e) {

		}

		if (toDelete == null) {
			return false;
		} else {
			return true;
		}

	}

	/**
	 * Method to display the correct tab after an action. 
	 * The tab selected for viewing is where the specified item reside in. 
	 * Method is shared among all commands.
	 * 
	 * @param item
	 */
	protected void showCorrectTab(Item item) {

		if (item.getType().toLowerCase().equals(POMPOM.LABEL_EVENT.toLowerCase())) {
			if (item.getStatus().equals(POMPOM.STATUS_COMPLETED)) {
				POMPOM.setCurrentTab(POMPOM.LABEL_COMPLETED_EVENT);
			} else {
				POMPOM.setCurrentTab(POMPOM.LABEL_EVENT);
			}
		} else {
			if (item.getStatus().equals(POMPOM.STATUS_COMPLETED)) {
				POMPOM.setCurrentTab(POMPOM.LABEL_COMPLETED_TASK);
			} else {
				POMPOM.setCurrentTab(POMPOM.LABEL_TASK);
			}
		}

	}

	/**
	 * Executes all the actions needed when the command is invoked.
	 * 
	 * @return the appropriate feedback message 
	 */
	public abstract String execute();

}
```
###### src\command\DelCommand.java
``` java
 */
public class DelCommand extends Command {

	/** Messaging **/
	public static final String MESSAGE_TASK_DELETED = "%1s has been deleted from %2s";
	public static final String MESSAGE_ID_INVALID = "%s is not a valid ID!";

	/** Command Parameters **/
	private Long taskId;
	private boolean isUndo;
	private boolean canDelete;
	private Item toDelete;
	ArrayList<Item> taskList = getTaskList();

	/**
	 * Constructor for a normal delete command
	 * 
	 * @param taskId
	 */
	public DelCommand(Long taskId) {
		this.taskId = taskId;
		this.isUndo = false;
		this.toDelete = getTask(taskId);

		logger.log(Level.INFO, "DelCommand with id initialized");
	}

	/**
	 * Constructor for an undo delete command
	 * 
	 * @param taskId
	 * @param isUndo
	 */
	public DelCommand(Long taskId, boolean isUndo) {
		this.taskId = taskId;
		this.isUndo = isUndo;

		logger.log(Level.INFO, "Counter action DelCommand initialized");
	}

	/**
	 * Method that do the actual removing of task from storage
	 */
	private void removeTask() {

		ArrayList<Item> taskList = getTaskList();
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getId().equals(taskId)) {
				taskList.remove(i);
			}
		}
		POMPOM.getStorage().setTaskList(taskList);
	}

	/**
	 * Creates the reverse action for undo. For DelCommand, the reverse would be
	 * AddCommand.
	 * 
	 * @return the reverse command
	 */
	private Command createCounterAction() {
		AddCommand counterAction = new AddCommand(toDelete.getId(), toDelete.getType(), toDelete.getTitle(),
				toDelete.getDescription(), toDelete.getPriority(), toDelete.getStatus(), toDelete.getLabel(),
				toDelete.getStartDate(), toDelete.getEndDate(), toDelete.isRecurring(), toDelete.getPrevId(),
				toDelete.getNextId());
		return counterAction;
	}

	/**
	 * Adds the reverse command into the undo stack
	 */
	private void updateUndoStack() {
		Command counterAction = createCounterAction();
		POMPOM.getUndoStack().push(counterAction);
	}

	/**
	 * Sets the pointer of the recurring tasks. Like a linked list, when the
	 * middle element is deleted, the pointers of the previous node should link
	 * to the next node.
	 */
	private void setProperPointers() {

		Item currentTask = getTask(toDelete.getId());

		Item prevTask = getTask(currentTask.getPrevId()); 
		prevTask.setNextId(currentTask.getNextId());

		Item nextTask = getTask(currentTask.getNextId());
		nextTask.setPrevId(currentTask.getPrevId());

	}

	/**
	 * Sets the proper return message to return
	 */
	private void setProperReturnMessage() {

		if (canDelete) {
			if (toDelete.getType().toLowerCase().equals(POMPOM.LABEL_EVENT.toLowerCase())) {
				if (toDelete.getStatus().equals(POMPOM.STATUS_COMPLETED)) {
					returnMsg = String.format(MESSAGE_TASK_DELETED, taskId, POMPOM.LABEL_COMPLETED_EVENT);
				} else {
					returnMsg = String.format(MESSAGE_TASK_DELETED, taskId, POMPOM.LABEL_EVENT);
				}
			} else {
				if (toDelete.getStatus().equals(POMPOM.STATUS_COMPLETED)) {
					returnMsg = String.format(MESSAGE_TASK_DELETED, taskId, POMPOM.LABEL_COMPLETED_TASK);
				} else {
					returnMsg = String.format(MESSAGE_TASK_DELETED, taskId, POMPOM.LABEL_TASK);
				}
			}
		} else {
			returnMsg = String.format(MESSAGE_ID_INVALID, taskId);
		}
	}

	/**
	 * Executes all the actions needed when a delete command is invoked
	 * 
	 * @return the appropriate feedback message
	 */
	public String execute() {

		canDelete = checkExists(taskId);

		toDelete = getTask(taskId);

		if (canDelete) {

			if (toDelete.isRecurring()) {
				setProperPointers();
			}

			if (!isUndo) {
				updateUndoStack();
			}

			removeTask();
			logger.log(Level.INFO, "DelCommand by Id has be executed");

			POMPOM.refreshStatus();
			showCorrectTab(toDelete);
			setProperReturnMessage();
			return returnMsg;

		} else {
			setProperReturnMessage();
			return returnMsg;
		}
	}
}
```
###### src\command\DelRecurringCommand.java
``` java
 */
public class DelRecurringCommand extends Command {

	/** Messaging **/
	public static final String MESSAGE_DELETE_RECURRING = "A series of recurring tasks has been deleted";
	public static final String MESSAGE_DELETE_RECUR_ERROR = "%s is not a reuccring task!";
	public static final String MESSAGE_INVALID = "%s is not a valid ID!";
	
	/** Command Parameters **/
	private Long taskId;
	private Long[] idList;
	boolean isUndo;
	ArrayList<Item> addList;
	ArrayList<Item> taskList = getTaskList();

	/**
	 * Constructor for DelRecurringCommand object
	 * 
	 * @param taskId
	 */
	public DelRecurringCommand(Long taskId) {
		this.taskId = taskId;
		this.addList = new ArrayList<Item>(); 
		this.isUndo = false;

		logger.log(Level.INFO, "DelRecurringCommand initialized");
	}
	
	/**
	 * Constructor for an undo DelRecurringCommand object
	 * 
	 * @param idList
	 */
	public DelRecurringCommand(Long[] idList) {
		this.idList = idList;
		this.isUndo = true;

		logger.log(Level.INFO, "Counter DelRecurringCommand initialized");
	}

	/**
	 * Method that do the actual removing of task from storage
	 */
	private void removeTask(Long taskId) {

		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getId().equals(taskId)) {
				taskList.remove(i);
			}
		}
		POMPOM.getStorage().setTaskList(taskList);

	}

	/**
	 * Creates the reverse action for undo. 
	 * For DelRecurringCommand, the reverse would be AddRecurringCommand.
	 * 
	 * @return the reverse command
	 */
	private Command createCounterAction() {
		return new AddRecurringCommand(addList, true);
	}
	
	/**
	 * Adds the reverse command into the undo stack
	 */
	private void updateUndoStack() {
		Command counterAction = createCounterAction();
		POMPOM.getUndoStack().push(counterAction);
	}

	/**
	 * Executes all the actions needed when a DelRecurringCommand is invoked
	 * 
	 * @return the appropriate feedback message 
	 */
	public String execute() {

		if (!isUndo) {
			
			Long firstId = taskId;
			Item firstTask = getTask(firstId); 
			
			
			if(firstTask == null){
				return String.format(MESSAGE_INVALID, firstId);
			} 			
			
			if(!firstTask.isRecurring()|| firstTask.getId() == null){
				returnMsg = String.format(MESSAGE_DELETE_RECUR_ERROR, firstId);
				return returnMsg;
			}
			
			while (true) {
				
				Item currentTask = getTask(taskId);
				
				addList.add(currentTask);
					
				Long nextId = getTask(taskId).getNextId();
				removeTask(taskId);
				taskId = nextId;
				
				if (taskId.equals(firstId)) {
					break;
				}
				
			} 
			
			updateUndoStack();
			POMPOM.refreshStatus();
			showCorrectTab(firstTask);

			returnMsg = MESSAGE_DELETE_RECURRING;
			return returnMsg;
			
		} else {
			
			Item firstTask = getTask(idList[0]);
			for (int i = 0; i < idList.length; i++) {
				Long currentId = idList[i];
				removeTask(currentId);
			}
			
			POMPOM.refreshStatus();
			showCorrectTab(firstTask);
			
			returnMsg = MESSAGE_DELETE_RECURRING;
			return returnMsg;
			
		}
	}

}
```
###### src\command\EditCommand.java
``` java
 */
public class EditCommand extends Command {

	/** Messaging **/
	public static final String MESSAGE_TASK_EDITED = "%s was successfully edited";
	public static final String MESSAGE_TASK_ERROR = "%s is not a valid ID!";
	public static final String MESSAGE_DATE_CHANGE_ERROR = "Start date must be earlier then end date";

	/** Input Field Types **/
	private static final String FIELD_TYPE = "type";
	private static final String FIELD_TITLE = "title";
	private static final String FIELD_DESCRIPTION = "description";
	private static final String FIELD_PRIORITY = "priority";
	private static final String FIELD_STATUS = "status";
	private static final String FIELD_LABEL = "label";
	private static final String FIELD_START_DATE = "start date";
	private static final String FIELD_END_DATE = "end date";

	/** Command Parameters **/
	public Long taskId;
	private String field;
	private String newData;
	private Date newDate;
	private Item task;
	private boolean canEdit;
	private boolean isUndo;

	/**
	 * Constructor for a normal edit command with String data
	 * 
	 * @param taskId
	 * @param field
	 * @param newData
	 */
	public EditCommand(Long taskId, String field, String newData) {
		this.taskId = taskId;
		this.task = getTask(taskId);
		this.field = field;
		this.newData = newData;
		isUndo = false;

		logger.log(Level.INFO, "EditCommand initialized");
	}

	/**
	 * Constructor for a normal edit command with Date data
	 * 
	 * @param taskId
	 * @param field
	 * @param newDate
	 */
	public EditCommand(Long taskId, String field, Date newDate) {
		this.taskId = taskId;
		this.task = getTask(taskId);
		this.field = field;
		this.newDate = newDate;
		isUndo = false;

		logger.log(Level.INFO, "EditCommand initialized");
	}

	/**
	 * Constructor for an undo edit command with String data
	 * 
	 * @param taskId
	 * @param field
	 * @param newData
	 * @param isUndo
	 */
	public EditCommand(Long taskId, String field, String newData, boolean isUndo) {
		this.taskId = taskId;
		this.task = getTask(taskId);
		this.field = field;
		this.newData = newData;
		this.isUndo = isUndo;

		logger.log(Level.INFO, "Counter action EditCommand initialized");
	}

	/**
	 * Constructor for an undo edit command with Date data
	 * 
	 * @param taskId
	 * @param field
	 * @param newDate
	 * @param isUndo
	 */
	public EditCommand(Long taskId, String field, Date newDate, boolean isUndo) {
		this.taskId = taskId;
		this.task = getTask(taskId);
		this.field = field;
		this.newDate = newDate;
		this.isUndo = isUndo;

		logger.log(Level.INFO, "Counter action EditCommand initialized");
	}

	/**
	 * Method that carries out the actual editing action
	 */
	private void updateChanges() {

		switch (field.toLowerCase()) {
		case FIELD_TITLE:
			task.setTitle(newData);
			break;
		case FIELD_TYPE:
			task.setType(newData);
			break;
		case FIELD_DESCRIPTION:
			task.setDescription(newData);
			break;
		case FIELD_PRIORITY:
			task.setPriority(newData);
			break;
		case FIELD_STATUS:
			task.setStatus(newData);
			break;
		case FIELD_LABEL:
			task.setLabel(newData);
			break;
		case FIELD_START_DATE:
			task.setStartDate(newDate);
			break;
		case FIELD_END_DATE:
			task.setEndDate(newDate);
			break;
		}

	}

	/**
	 * Creates the reverse action for undo. For EditCommand, the reverse would
	 * be another EditCommand with the old data.
	 * 
	 * @return the reverse command
	 */
	private Command createCounterAction() {
		EditCommand counterAction;

		switch (field.toLowerCase()) {
		case FIELD_TITLE:
			counterAction = new EditCommand(taskId, field, task.getTitle(), true);
			break;
		case FIELD_DESCRIPTION:
			counterAction = new EditCommand(taskId, field, task.getDescription(), true);
			break;
		case FIELD_PRIORITY:
			counterAction = new EditCommand(taskId, field, task.getPriority(), true);
			break;
		case FIELD_STATUS:
			counterAction = new EditCommand(taskId, field, task.getStatus(), true);
			break;
		case FIELD_LABEL:
			counterAction = new EditCommand(taskId, field, task.getLabel(), true);
			break;
		case FIELD_START_DATE:
			counterAction = new EditCommand(taskId, field, task.getStartDate(), true);
			break;
		case FIELD_END_DATE:
			counterAction = new EditCommand(taskId, field, task.getEndDate(), true);
			break;
		default:
			counterAction = null;
			break;
		}

		return counterAction;

	}

	/**
	 * Adds the reverse command into the undo stack
	 */
	private void updateUndoStack() {
		Command counterAction = createCounterAction();
		POMPOM.getUndoStack().push(counterAction);
	}

	/**
	 * Executes all the actions needed when an edit command is invoked
	 * 
	 * @return the appropriate feedback message
	 */
	public String execute() {

		canEdit = checkExists(taskId);

		if (canEdit) {
			if (!isUndo) {
				updateUndoStack();
			}
			updateChanges();

			// Ensures that end date is after start date
			if (task.getStartDate() != null && task.getEndDate() != null) {
				if (task.getEndDate().compareTo(task.getStartDate()) < 0) {
					POMPOM.getUndoStack().pop().execute();
					returnMsg = MESSAGE_DATE_CHANGE_ERROR;
					return returnMsg;
				}
			}

			returnMsg = String.format(MESSAGE_TASK_EDITED, taskId);
			ArrayList<Item> taskList = getTaskList();
			POMPOM.getStorage().setTaskList(taskList);

		} else {
			
			returnMsg = String.format(MESSAGE_TASK_ERROR, taskId);
			return returnMsg;
		}

		POMPOM.refreshStatus();
		showCorrectTab(task);

		logger.log(Level.INFO, "EditCommand has be executed");
		return returnMsg;
	}

}
```
###### src\command\EditRecurringCommand.java
``` java
 */
public class EditRecurringCommand extends Command {

	/** Messaging **/
	public static final String MESSAGE_EDIT_RECURRING = "A series of recurring tasks has been edited";
	public static final String MESSAGE_EDIT_RECUR_ERROR = "%s is not a reuccring task!";

	/** Input Field Types **/
	private static final String FIELD_TITLE = "title";
	private static final String FIELD_DESCRIPTION = "description";
	private static final String FIELD_PRIORITY = "priority";
	private static final String FIELD_LABEL = "label";

	/** Command Parameters **/
	private Long firstId;
	private Long taskId;
	boolean isUndo;
	private String field;
	private String newData;
	ArrayList<String> oldData;
	ArrayList<Item> taskList = getTaskList();

	/**
	 * Constructor for EditRecurringCommand object
	 * 
	 * @param taskId
	 * @param field
	 * @param newData
	 */
	public EditRecurringCommand(Long taskId, String field, String newData) {
		this.taskId = taskId;
		this.field = field;
		this.newData = newData;
		this.oldData = new ArrayList<String>();
		this.isUndo = false;

		logger.log(Level.INFO, "EditRecurringCommand initialized");
	}

	/**
	 * Constructor for an undo EditRecurringCommand object
	 * 
	 * @param taskId
	 * @param field
	 * @param oldData
	 */
	public EditRecurringCommand(Long taskId, String field,
			ArrayList<String> oldData) {
		this.taskId = taskId;
		this.field = field;
		this.oldData = oldData;
		this.isUndo = true;

		logger.log(Level.INFO, " Counter EditRecurringCommand initialized");
	}

	/**
	 * Method that carries out the actual editing action. This is for the normal
	 * Edit Recurring as the old data needs to be saved.
	 * 
	 * @param taskId
	 */
	private void updateChanges(Long taskId) {

		Item currentTask = getTask(taskId);

		switch (field.toLowerCase()) {
		case FIELD_TITLE:
			oldData.add(currentTask.getTitle());
			currentTask.setTitle(newData);
			break;
		case FIELD_DESCRIPTION:
			oldData.add(currentTask.getDescription());
			currentTask.setDescription(newData);
			break;
		case FIELD_PRIORITY:
			oldData.add(currentTask.getPriority());
			currentTask.setPriority(newData);
			break;
		case FIELD_LABEL:
			oldData.add(currentTask.getLabel());
			currentTask.setLabel(newData);
			break;
		}

	}

	/**
	 * Method that carries out the actual editing action. This is for the undo
	 * Edit Recurring as the old data needs to be specified.
	 * 
	 * @param taskId
	 * @param oldData
	 */
	private void updateChanges(Long taskId, String oldData) {

		Item currentTask = getTask(taskId);

		switch (field.toLowerCase()) {
		case FIELD_TITLE:
			currentTask.setTitle(oldData);
			break;
		case FIELD_DESCRIPTION:
			currentTask.setDescription(oldData);
			break;
		case FIELD_PRIORITY:
			currentTask.setPriority(oldData);
			break;
		case FIELD_LABEL:
			currentTask.setLabel(oldData);
			break;
		}

	}

	/**
	 * Creates the reverse action for undo. For EditRecurringCommand, the
	 * reverse would be another EditRecurringCommand with the old data.
	 * 
	 * @return the reverse command
	 */
	private Command createCounterAction() {
		return new EditRecurringCommand(firstId, field, oldData);
	}

	/**
	 * Adds the reverse command into the undo stack
	 */
	private void updateUndoStack() {
		Command counterAction = createCounterAction();
		POMPOM.getUndoStack().push(counterAction);
	}

	/**
	 * Executes all the actions needed when an EditRecurringCommand is invoked
	 * 
	 * @return the appropriate feedback message
	 */
	public String execute() {

		this.firstId = taskId;
		Item firstTask = getTask(firstId);

		if (firstTask.isRecurring()) {
			if (!isUndo) {

				while (taskId != null) {
					Item currentTask = getTask(taskId);

					Long nextId = currentTask.getNextId();
					updateChanges(taskId);
					taskId = nextId;

					if (taskId.equals(firstId)) {
						break;
					}
				}

				updateUndoStack();
				POMPOM.refreshStatus();
				showCorrectTab(firstTask);

				returnMsg = MESSAGE_EDIT_RECURRING;
				return returnMsg;

			} else {

				Long firstId = taskId;
				int counter = 0;

				while (taskId != null) {
					Long nextId = getTask(taskId).getNextId();
					updateChanges(taskId, oldData.get(counter));
					taskId = nextId;
					counter++;

					if (taskId.equals(firstId)) {
						break;
					}
				}

				POMPOM.refreshStatus();
				showCorrectTab(firstTask);

				returnMsg = MESSAGE_EDIT_RECURRING;
				return returnMsg;

			}
		} else {

			returnMsg = String.format(MESSAGE_EDIT_RECUR_ERROR, firstId);
			return returnMsg;
		}

	}

}
```
###### src\command\ExitCommand.java
``` java
 */
public class ExitCommand extends Command{
	
	/**
	 * Constructor for ExitCommand object.
	 * It saves the storage when initialized.
	 */
	public ExitCommand() {
		try {
			POMPOM.getStorage().saveStorage();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}

	/**
	 * Carries out the action of exiting
	 */
	public String execute() {
		System.exit(0);
		return returnMsg;
	}
}
```
###### src\command\HelpCommand.java
``` java
 */
public class HelpCommand extends Command {
	
	/** Messaging **/
	private String MESSAGE_HELP = "Help dialog requested";
	
	/**
	 * Constructor for HelpCommand
	 */
	public HelpCommand() {
		
	}
	
	/**
	 * Carries out the action of showing the help dialog
	 */
	public String execute() {
		POMPOM.showHelp = true;
		String returnMsg = String.format(MESSAGE_HELP);
		return returnMsg;
	}
}
```
###### src\command\InvalidCommand.java
``` java
 */
public class InvalidCommand extends Command {

	/** Command Parameter **/
	private String error;

	/**
	 * Constructor for InvalidCommand object
	 * 
	 * @param error
	 */
	public InvalidCommand(String error) {
		this.error = error;
	}

	/**
	 * Does nothing and only return the error. 
	 * Error message should already be formatted before reaching this point.
	 */
	public String execute() {
		return error;
	}

}
```
###### src\command\PathCommand.java
``` java
 */
public class PathCommand extends Command {
	
	/** Messaging **/
	private static final String MESSAGE_SET_PATH = "Storage path set to: %s";
	
	/** Command Parameter **/
	private String storageFilePath;
	
	/**
	 * Constructor for PathCommand object
	 * 
	 * @param storageFilePath
	 */
	public PathCommand(String storageFilePath) {
		this.storageFilePath = storageFilePath;
	}
	

	/**
	 * Carries out the action of changing storage path
	 */
	public String execute() {
		
		POMPOM.getStorage().setStorageFilePath(storageFilePath);
		
		// Saves settings and reinitializes storage
		try {
			POMPOM.getStorage().saveSettings();
			POMPOM.getStorage().init();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		logger.log(Level.INFO, "PathCommand has be executed");
		returnMsg = String.format(MESSAGE_SET_PATH, storageFilePath);
		return returnMsg;
	}
	
}
```
###### src\command\SearchCommand.java
``` java
 */
public class SearchCommand extends Command {

	/** Messaging **/
	private static final String MESSAGE_SEARCH = "Search resulted in %s result(s).";

	/** Command Parameters **/
	private static final double PERCENT_TO_ACCEPT = 60.0;
	public ArrayList<Item> searchResults;
	private String keyword;
	private ArrayList<String> keywordTokens;

	/**
	 * Constructor for SearchCommand object
	 * 
	 * @param keyword
	 */
	public SearchCommand(String keyword) {
		this.searchResults = new ArrayList<Item>();
		this.keyword = keyword;
		this.keywordTokens = tokenize(keyword);
	}

	/**
	 * Method to search for items the relevant to keyword. Tokenizes the keyword
	 * and every item title. If any title token is 60% similar to any keyword
	 * token, it is deemed as relevant and will turn up in search results.
	 * 
	 * @return ArrayList of items that are relevant to search keyword
	 */
	private ArrayList<Item> search() {

		ArrayList<Item> taskList = getTaskList();
		boolean toAdd = false;

		for (int i = 0; i < taskList.size(); i++) {

			Item currentTask = taskList.get(i);
			ArrayList<String> taskTitleTokens = tokenize(currentTask.getTitle());
			for (int j = 0; j < taskTitleTokens.size(); j++) {
				for (int k = 0; k < keywordTokens.size(); k++) {

					String titleToken = taskTitleTokens.get(j);
					String keyToken = keywordTokens.get(k);

					double percentSimilarity = computeStrSimilarity(titleToken, keyToken);

					if (percentSimilarity >= PERCENT_TO_ACCEPT) {
						toAdd = true;
						break;
					}

				}

				if (toAdd) {
					break;
				}

			}

			if (toAdd) {
				searchResults.add(currentTask);
				toAdd = false;
			}

		}

		return searchResults;

	}

	
	/**
	 * Method to tokenize String according to space.
	 * 
	 * @param keyword
	 * @return ArrayList of String tokens
	 */
	private static ArrayList<String> tokenize(String keyword) {

		StringTokenizer tokenizer = new StringTokenizer(keyword);
		ArrayList<String> strTokens = new ArrayList<String>();

		// Tokenizes the search String taken in
		while (tokenizer.hasMoreTokens()) {
			strTokens.add(tokenizer.nextToken());
		}
		
		return strTokens;
	}

	
	/**
	 * Computes the distance between the 2 strings
	 * using the Levenshtein Distance Algorithm
	 * 
	 * @param   s1
	 * @param   s2
	 * @return  the edit distance between s1 and s2
	 */
	private static int computeEditDistance(String s1, String s2) {

		s1 = s1.toLowerCase();
		s2 = s2.toLowerCase();
		int[] costToChange = new int[s2.length() + 1];

		for (int i = 0; i <= s1.length(); i++) {
			int lastValue = i;
			for (int j = 0; j <= s2.length(); j++) {
				if (i == 0) {
					costToChange[j] = j;
				} else {
					if (j > 0) {
						int newValue = costToChange[j - 1];
						if (s1.charAt(i - 1) != s2.charAt(j - 1)) {
							newValue = Math.min(Math.min(newValue, lastValue), costToChange[j]) + 1;
						}
						costToChange[j - 1] = lastValue;
						lastValue = newValue;
					}
				}
			}
			if (i > 0) {
				costToChange[s2.length()] = lastValue;
			}
		}
		return costToChange[s2.length()];
	}

	
	/**
	 * Computes the similarity between 2 strings 
	 * using the computerEditDistance method
	 * 
	 * @param   s1
	 * @param   s2
	 * @return  the similarity between s1 and s2
	 */
	public static double computeStrSimilarity(String s1, String s2) {
		
		// s1 should always be bigger, for easy check thus the swapping.
		if (s2.length() > s1.length()) {
			String tempStr = s1;
			s1 = s2;
			s2 = tempStr;
		}

		int MAX_PERCENT = 100;
		int MAX_LENGTH = s1.length();

		if (MAX_LENGTH == 0) {
			return MAX_PERCENT;
		}
		return ((MAX_LENGTH - computeEditDistance(s1, s2)) / (double) MAX_LENGTH) * MAX_PERCENT;
	}

	/**
	 * Executes all the actions needed when an SearchCommand is invoked
	 * 
	 * @return the appropriate feedback message 
	 */
	public String execute() {

		POMPOM.setSearchList(search());
		POMPOM.setCurrentTab(POMPOM.LABEL_SEARCH);
		GUIModel.update();
		logger.log(Level.INFO, "SearchCommand has be executed");
		returnMsg = String.format(MESSAGE_SEARCH, searchResults.size());
		return returnMsg;

	}

}
```
###### src\command\UndoCommand.java
``` java
 */
public class UndoCommand extends Command {

	/** Messaging **/
	public static final String MESSAGE_UNDO = "Previous action has been successfully undone";
	public static final String MESSAGE_ERROR = "There is nothing to undo";

	/**
	 * Executes all the actions needed when an UndoCommand is invoked
	 * 
	 * @return the appropriate feedback message
	 */
	public String execute() {

		Stack<Command> undoStack = POMPOM.getUndoStack();

		// checks if stack is empty as popping an empty stack will cause
		// exceptions
		if (undoStack.isEmpty()) {
			returnMsg = MESSAGE_ERROR;
			return returnMsg;
		} else {
			Command undo = undoStack.pop();
			undo.execute();
			logger.log(Level.INFO, "UndoCommand has be executed");
			returnMsg = MESSAGE_UNDO;
			return returnMsg;
		}
	}

}
```
###### src\command\ViewCommand.java
``` java
 */
public class ViewCommand extends Command {

	/** Messaging **/
	private static final String MESSAGE_VIEW = "%s tab has been selected for viewing.";
	private static final String MESSAGE_ERROR = "%s is not a valid tab.";
	
	/** Command Parameter **/
	private String tab;

	/**
	 * Constructor for ViewCommand object
	 * 
	 * @param tab
	 */
	public ViewCommand(String tab) {
		this.tab = tab;
	} 
	
	/**
	 * Executes the action of swapping tabs when a ViewCommand is invoked
	 * 
	 * @return the appropriate feedback message 
	 */
	public String execute() {
		
		if (tab.equalsIgnoreCase(POMPOM.LABEL_COMPLETED_EVENT)) {
			tab = POMPOM.LABEL_COMPLETED_EVENT;
			POMPOM.setCurrentTab(tab);
			returnMsg = String.format(MESSAGE_VIEW, tab);
			return returnMsg;
		} else if (tab.equalsIgnoreCase(POMPOM.LABEL_COMPLETED_TASK)) {
			tab = POMPOM.LABEL_COMPLETED_TASK;
			POMPOM.setCurrentTab(tab);
			returnMsg = String.format(MESSAGE_VIEW, tab);
			return returnMsg;
		} else if (tab.equalsIgnoreCase(POMPOM.LABEL_EVENT)) {
			tab = POMPOM.LABEL_EVENT;
			POMPOM.setCurrentTab(tab);
			returnMsg = String.format(MESSAGE_VIEW, tab);
			return returnMsg;
		} else if (tab.equalsIgnoreCase(POMPOM.LABEL_TASK)) {
			tab = POMPOM.LABEL_TASK;
			POMPOM.setCurrentTab(tab);
			returnMsg = String.format(MESSAGE_VIEW, tab);
			return returnMsg;
		} else if (tab.equalsIgnoreCase(POMPOM.LABEL_SEARCH)) {
			tab = POMPOM.LABEL_SEARCH;
			POMPOM.setCurrentTab(tab);
			returnMsg = String.format(MESSAGE_VIEW, tab);
			return returnMsg;
		} else {
			returnMsg = String.format(MESSAGE_ERROR, tab);
			return returnMsg;
		}

	}

}
```
###### src\main\POMPOM.java
``` java
 *
 */
public class POMPOM {

	public static final String STATUS_PENDING = "Pending";
	public static final String STATUS_ONGOING = "Ongoing";
	public static final String STATUS_COMPLETED = "Completed";
	public static final String STATUS_OVERDUE = "Overdue";
	public static final String STATUS_FLOATING = "Floating";

	public static final String LABEL_TASK = "Task";
	public static final String LABEL_COMPLETED_TASK = "CompletedTask";
	public static final String LABEL_EVENT = "Event";
	public static final String LABEL_COMPLETED_EVENT = "CompletedEvent";
	public static final String LABEL_SEARCH = "Search";
	
	public static final String PRIORITY_HIGH = "high";
	public static final String PRIORITY_MED = "medium";
	public static final String PRIORITY_LOW = "low";

	private static Storage storage;
	private static Stack<Command> undoStack;
	public static PrettyTimeParser timeParser;
	public static ArrayList<Item> searchList;
	public static String currentTab;
	public static boolean showHelp = false;
	public POMPOM() {
		try {
			init();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	private void init() throws IOException {
		try {
			storage = new Storage();
			storage.init();
			undoStack = new Stack<Command>();
			refreshStatus();
			timeParser = new PrettyTimeParser();
			timeParser.parseSyntax("next year");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public static void refreshStatus() {
		ArrayList<Item> taskList = storage.getTaskList();
		Date currentDate = new Date();

		for (int i = 0; i < taskList.size(); i++) {
			Item currentTask = taskList.get(i);
			Date taskStartDate = currentTask.getStartDate();
			Date taskEndDate = currentTask.getEndDate();

			if (currentTask.getType().equals(LABEL_TASK)) {
				
				if (isNotCompleted(currentTask)) {
					if (taskStartDate == null && taskEndDate == null) {
						currentTask.setStatus(STATUS_FLOATING);
					} else if (taskEndDate == null) {
						if (currentDate.before(taskStartDate)) {
							currentTask.setStatus(STATUS_PENDING);
						} else {
							currentTask.setStatus(STATUS_ONGOING);
						}
					} else if (taskStartDate == null) {
						if (currentDate.before(taskEndDate)) {
							currentTask.setStatus(STATUS_ONGOING);
						} else {
							currentTask.setStatus(STATUS_OVERDUE);
						}
					} else if (currentDate.before(taskStartDate)) {
						currentTask.setStatus(STATUS_PENDING);
					} else if (currentDate.after(taskStartDate) && currentDate.before(taskEndDate)) {
						currentTask.setStatus(STATUS_ONGOING);
					} else if (currentDate.after(taskStartDate) && currentDate.after(taskEndDate)) {
						currentTask.setStatus(STATUS_OVERDUE);
					}
				}

			} else {
				
				if (isNotCompleted(currentTask)) {
					if (currentDate.before(taskStartDate)) {
						currentTask.setStatus(STATUS_PENDING);
					} else if (currentDate.after(taskStartDate) && currentDate.before(taskEndDate)) {
						currentTask.setStatus(STATUS_ONGOING);
					} else if (currentDate.after(taskStartDate) && currentDate.after(taskEndDate)) {
						currentTask.setStatus(STATUS_COMPLETED);
					}
				}
				
			}
		}
	}

	public String execute(String input) {
		Parser parser = Parser.getInstance();
		Command command = parser.parse(input);
		String returnMsg = command.execute();
		refreshStatus();
		return returnMsg;
	}

	public static String executeCommand(Command executable) {
		String returnMsg = executable.execute();
		refreshStatus();
		return returnMsg;
	}

	private static boolean isNotCompleted(Item item) {
		
		return !item.getStatus().equalsIgnoreCase(STATUS_COMPLETED);

	}

	public static PrettyTimeParser getTimeParser() {
		return timeParser;
	}

	public static void setTimeParser(PrettyTimeParser timeParser) {
		POMPOM.timeParser = timeParser;
	}

	public static Storage getStorage() {
		return storage;
	}

	public static Stack<Command> getUndoStack() {
		return undoStack;
	}

	public static void saveSettings(String storageFilePath) throws IOException {
		storage.setStorageFilePath(storageFilePath);
		storage.saveSettings();
	}

	public static String getCurrentTab() {
		return POMPOM.currentTab;
	}

	public static void setCurrentTab(String setTab) {
		POMPOM.currentTab = setTab;
	}

	public static ArrayList<Item> getSearchList() {
		return searchList;
	}

	public static void setSearchList(ArrayList<Item> searchList) {
		POMPOM.searchList = searchList;
	}

}
```
###### src\Test\TestCommand.java
``` java
 *
 */
public class TestCommand {

	/** Parameters **/ 
	POMPOM pompom;
	ArrayList<Item> taskList;
	Date currentDate;
	Date startDate;
	Date endDate;
	SimpleDateFormat formatter;

	/**
	 * This method initializes POMPOM class, the dates to be used and clears the
	 * storage for testing. Also initializes the SimpleDateFormat for later use.
	 */
	@Before
	public void initialize() {
		pompom = new POMPOM();
		taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();

		currentDate = new Date();
		startDate = parseDate("1 apr");
		endDate = parseDate("5 may 2020");
		formatter = new SimpleDateFormat("dd/MM/yyyy HH:mm");
	}

	/******************* HELPER METHODS *******************/

	private Date parseDate(String dateString) {
		List<Date> date;
		PrettyTimeParser timeParser = new PrettyTimeParser();

		if (dateString != null) {
			date = timeParser.parse(dateString);

			if (date.isEmpty()) {
				return null;
			} else {
				return date.get(0);
			}

		} else {
			return null;
		}

	}

	/******************* END OF HELPER METHODS ************/

	/******************* UNIT TEST CASES ******************/

	@Test
	public void testAdd() {

		AddCommand command = new AddCommand(POMPOM.LABEL_TASK, "do cs3241", "bezier curve", "medium", "ongoing", "lab",
				startDate, endDate);

		// check if the add command returns the right status message
		assertEquals("Task added", command.execute());

		// check if the taskList contain the added task
		Item addedTask = taskList.get(0);
		assertEquals("do cs3241", addedTask.getTitle());
		assertEquals("bezier curve", addedTask.getDescription());
		assertEquals("Medium", addedTask.getPriority());
		assertEquals("Ongoing", addedTask.getStatus());
		assertEquals("lab", addedTask.getLabel());

	}

	@Test
	public void testDelete() {

		testAdd();

		Item addedTask = taskList.get(0);

		DelCommand delete = new DelCommand(addedTask.getId());

		// check if the delete command returns the right status message
		assertEquals(addedTask.getId() + " has been deleted from " + addedTask.getType(), delete.execute());

		// check if the item was really deleted
		assertEquals(0, taskList.size());
	}

	@Test
	public void testEditTitle() {

		testAdd();

		Item addedTask = taskList.get(0);

		EditCommand edit = new EditCommand(addedTask.getId(), "title", "do cs2103t");

		// check if the edit command returns the right status message
		assertEquals(addedTask.getId() + " was successfully edited", edit.execute());

		// check if the edit command did edit the actual item
		assertEquals("do cs2103t", addedTask.getTitle());

	}

	@Test
	public void testEditDescription() {

		testAdd();

		Item addedTask = taskList.get(0);

		EditCommand edit = new EditCommand(addedTask.getId(), "description", "V0.2");

		// check if the edit command returns the right status message
		assertEquals(addedTask.getId() + " was successfully edited", edit.execute());

		// check if the edit command did edit the actual item
		assertEquals("V0.2", addedTask.getDescription());

	}

	@Test
	public void testEditPriority() {

		testAdd();

		Item addedTask = taskList.get(0);

		EditCommand edit = new EditCommand(addedTask.getId(), "priority", "high");

		// check if the edit command returns the right status message
		assertEquals(addedTask.getId() + " was successfully edited", edit.execute());

		// check if the edit command did edit the actual item
		assertEquals("High", addedTask.getPriority());

	}

	@Test
	public void testEditStatus() {

		testAdd();

		Item addedTask = taskList.get(0);

		EditCommand edit = new EditCommand(addedTask.getId(), "status", POMPOM.STATUS_COMPLETED);

		// check if the edit command returns the right status message
		assertEquals(addedTask.getId() + " was successfully edited", edit.execute());

		// check if the edit command did edit the actual item
		assertEquals("Completed", addedTask.getStatus());

	}

	@Test
	public void testEditLabel() {

		testAdd();

		Item addedTask = taskList.get(0);

		EditCommand edit = new EditCommand(addedTask.getId(), "label", "deadline");

		// check if the edit command returns the right status message
		assertEquals(addedTask.getId() + " was successfully edited", edit.execute());

		// check if the edit command did edit the actual item
		assertEquals("deadline", addedTask.getLabel());

	}

	@Test
	public void testEditStartDate() throws ParseException {

		testAdd();

		Item addedTask = taskList.get(0);

		Date editDate = parseDate("2 apr 1pm");

		EditCommand edit = new EditCommand(addedTask.getId(), "start date", editDate);

		// check if the edit command returns the right status message
		assertEquals(addedTask.getId() + " was successfully edited", edit.execute());

		String date = formatter.format(addedTask.getStartDate());

		// check if the edit command did edit the actual item
		assertEquals("02/04/2016 13:00", date);

	}

	@Test
	public void testUndoAdd() {

		testAdd();

		UndoCommand undo = new UndoCommand();

		// check if the undo command returns the right status message
		assertEquals("Previous action has been successfully undone", undo.execute());

		// check if the taskList is empty because add was undone
		assertEquals(0, taskList.size());

	}

	@Test
	public void testUndoDelete() {

		testAdd();

		Item addedTask = taskList.get(0);

		DelCommand delete = new DelCommand(addedTask.getId());

		// check if the delete command returns the right status message
		assertEquals(addedTask.getId() + " has been deleted from " + addedTask.getType(), delete.execute());

		// check if the item was really deleted
		assertEquals(0, taskList.size());

		UndoCommand undo = new UndoCommand();

		// check if the undo command returns the right status message
		assertEquals("Previous action has been successfully undone", undo.execute());

		// check if the taskList contain the recovered task
		Item recoveredTask = taskList.get(0);
		assertEquals("do cs3241", recoveredTask.getTitle());
		assertEquals("bezier curve", recoveredTask.getDescription());
		assertEquals("Medium", recoveredTask.getPriority());
		assertEquals("Ongoing", recoveredTask.getStatus());
		assertEquals("lab", recoveredTask.getLabel());

	}

	@Test
	public void testUndoEditTitle() {

		testAdd();

		Item addedTask = taskList.get(0);

		EditCommand edit = new EditCommand(addedTask.getId(), "title", "do cs2103t");

		// check if the edit command returns the right status message
		assertEquals(addedTask.getId() + " was successfully edited", edit.execute());

		// check if the edit command did edit the actual item
		assertEquals("do cs2103t", addedTask.getTitle());

		UndoCommand undo = new UndoCommand();

		// check if the undo command returns the right status message
		assertEquals("Previous action has been successfully undone", undo.execute());

		// check if the title changed back to previous title
		assertEquals("do cs3241", addedTask.getTitle());

	}

	@Test
	public void testUndoEmpty() {

		pompom = new POMPOM();
		UndoCommand undo = new UndoCommand();
		assertEquals("There is nothing to undo", undo.execute());

	}

	@Test
	public void testSearch() {

		// Populates task list for searching
		AddCommand command_0 = new AddCommand(POMPOM.LABEL_TASK, "do cs3241", "2d drawing", "low", "ongoing", "lab 1",
				startDate, endDate);
		AddCommand command_1 = new AddCommand(POMPOM.LABEL_TASK, "do cs3241", "solar system", "medium", "ongoing",
				"lab 2", startDate, endDate);
		AddCommand command_2 = new AddCommand(POMPOM.LABEL_TASK, "do cs3241", "3d drawing", "high", "ongoing", "lab 3",
				startDate, endDate);
		AddCommand command_3 = new AddCommand(POMPOM.LABEL_TASK, "do cs3241", "bezier curve", "high", "ongoing",
				"lab 4", startDate, endDate);
		AddCommand command_4 = new AddCommand(POMPOM.LABEL_TASK, "do cs2103t", "V0.2", "high", "ongoing", "deadline",
				startDate, endDate);

		// check if the add commands returns the right status message
		assertEquals("Task added", command_0.execute());
		assertEquals("Task added", command_1.execute());
		assertEquals("Task added", command_2.execute());
		assertEquals("Task added", command_3.execute());
		assertEquals("Task added", command_4.execute());

		SearchCommand search = new SearchCommand("cs3241");

		// check if the search command returns the right status message
		assertEquals("Search resulted in 4 result(s).", search.execute());

		// check if the all search results contains the keyword
		assertEquals(4, search.searchResults.size());
		for (int i = 0; i < 4; i++) {
			Item currentTask = search.searchResults.get(i);
			assertEquals(true, currentTask.getTitle().contains("cs3241"));
		}

	}

	@Test
	public void testView() {

		ViewCommand view = new ViewCommand("completedevent");
		assertEquals("CompletedEvent tab has been selected for viewing.", view.execute());
		assertEquals(POMPOM.LABEL_COMPLETED_EVENT, POMPOM.getCurrentTab());

		view = new ViewCommand("completedtask");
		assertEquals("CompletedTask tab has been selected for viewing.", view.execute());
		assertEquals(POMPOM.LABEL_COMPLETED_TASK, POMPOM.getCurrentTab());

		view = new ViewCommand("event");
		assertEquals("Event tab has been selected for viewing.", view.execute());
		assertEquals(POMPOM.LABEL_EVENT, POMPOM.getCurrentTab());

		view = new ViewCommand("task");
		assertEquals("Task tab has been selected for viewing.", view.execute());
		assertEquals(POMPOM.LABEL_TASK, POMPOM.getCurrentTab());

		view = new ViewCommand("search");
		assertEquals("Search tab has been selected for viewing.", view.execute());
		assertEquals(POMPOM.LABEL_SEARCH, POMPOM.getCurrentTab());

	}

	@Test
	public void testSetPath() {

		String currentPath = POMPOM.getStorage().getStorageFilePath();
		PathCommand path = new PathCommand(currentPath);
		assertEquals(String.format("Storage path set to: %s", currentPath), path.execute());

	}

	@Test
	public void testInvalid() {

		InvalidCommand invalid = new InvalidCommand("asd");
		assertEquals("asd", invalid.execute());

	}

	@Test
	public void testAddRecurring() {

		// add recurring tasks using POMPOM class to populating the tasks
		String returnMsg = pompom.execute("add do project f:4 apr e:5 apr r:daily until 6 apr");
 
		// check if the correct status message is returned
		assertEquals("Recurring tasks has been added", returnMsg);
 
		// check if the correct number of tasks has been added
		assertEquals(3, taskList.size());

		Item addedTask_1 = taskList.get(0);
		Item addedTask_2 = taskList.get(1);
		Item addedTask_3 = taskList.get(2);

		// check if all recurring tasks have the same title
		assertEquals("do project", addedTask_1.getTitle());
		assertEquals("do project", addedTask_2.getTitle());
		assertEquals("do project", addedTask_3.getTitle());

	}

	@Test
	public void testDelRecurringFirstTask() {

		testAddRecurring();

		Item addedTask_1 = taskList.get(0);

		DelRecurringCommand delRecurringCommand = new DelRecurringCommand(addedTask_1.getId());

		// check if the DelRecurringCommand returns the right status message
		assertEquals("A series of recurring tasks has been deleted", delRecurringCommand.execute());

		// check if all recurring tasks have been deleted
		assertEquals(0, taskList.size());

	}

	@Test
	public void testDelRecurringMiddleTask() {

		testAddRecurring();

		Item addedTask_2 = taskList.get(1);

		DelRecurringCommand delRecurringCommand = new DelRecurringCommand(addedTask_2.getId());

		// check if the DelRecurringCommand returns the right status message
		assertEquals("A series of recurring tasks has been deleted", delRecurringCommand.execute());

		// check if all recurring tasks have been deleted
		assertEquals(0, taskList.size());

	}

	@Test
	public void testDelRecurringLastTask() {

		testAddRecurring();

		Item addedTask_3 = taskList.get(2);

		DelRecurringCommand delRecurringCommand = new DelRecurringCommand(addedTask_3.getId());

		// check if the DelRecurringCommand returns the right status message
		assertEquals("A series of recurring tasks has been deleted", delRecurringCommand.execute());

		// check if all recurring tasks have been deleted
		assertEquals(0, taskList.size());

	}

	@Test
	public void testEditRecurringTitle() {

		testAddRecurring();

		Item addedTask_1 = taskList.get(0);
		Item addedTask_2 = taskList.get(1);
		Item addedTask_3 = taskList.get(2);

		EditRecurringCommand editRecurringCommand = new EditRecurringCommand(addedTask_1.getId(), "title",
				"it works perfectly");
		
		// check if the EditRecurringCommand returns the right status message
		assertEquals("A series of recurring tasks has been edited", editRecurringCommand.execute());

		// check if all recurring tasks have been edited
		assertEquals("it works perfectly", addedTask_1.getTitle());
		assertEquals("it works perfectly", addedTask_2.getTitle());
		assertEquals("it works perfectly", addedTask_3.getTitle());

	}

	@Test
	public void testEditRecurringDescription() {

		testAddRecurring();

		Item addedTask_1 = taskList.get(0);
		Item addedTask_2 = taskList.get(1);
		Item addedTask_3 = taskList.get(2);

		EditRecurringCommand editRecurringCommand = new EditRecurringCommand(addedTask_1.getId(), "description",
				"it works perfectly");
		
		// check if the EditRecurringCommand returns the right status message
		assertEquals("A series of recurring tasks has been edited", editRecurringCommand.execute());

		// check if all recurring tasks have been edited
		assertEquals("it works perfectly", addedTask_1.getDescription());
		assertEquals("it works perfectly", addedTask_2.getDescription());
		assertEquals("it works perfectly", addedTask_3.getDescription());

	}

	@Test
	public void testEditRecurringLabel() {

		testAddRecurring();

		Item addedTask_1 = taskList.get(0);
		Item addedTask_2 = taskList.get(1);
		Item addedTask_3 = taskList.get(2);

		EditRecurringCommand editRecurringCommand = new EditRecurringCommand(addedTask_1.getId(), "label",
				"work work work");
		
		// check if the EditRecurringCommand returns the right status message
		assertEquals("A series of recurring tasks has been edited", editRecurringCommand.execute());

		// check if all recurring tasks have been edited
		assertEquals("work work work", addedTask_1.getLabel());
		assertEquals("work work work", addedTask_2.getLabel());
		assertEquals("work work work", addedTask_3.getLabel());

	}

	@Test
	public void testEditRecurringPriority() {

		testAddRecurring();

		Item addedTask_1 = taskList.get(0);
		Item addedTask_2 = taskList.get(1);
		Item addedTask_3 = taskList.get(2);

		EditRecurringCommand editRecurringCommand = new EditRecurringCommand(addedTask_1.getId(), "priority", "high");
		
		// check if the EditRecurringCommand returns the right status message
		assertEquals("A series of recurring tasks has been edited", editRecurringCommand.execute());

		// check if all recurring tasks have been edited
		assertEquals("High", addedTask_1.getPriority());
		assertEquals("High", addedTask_2.getPriority());
		assertEquals("High", addedTask_3.getPriority());

	}

	@Test
	public void testEditRecurringFirstTask() {

		testAddRecurring();

		Item addedTask_1 = taskList.get(0);
		Item addedTask_2 = taskList.get(1);
		Item addedTask_3 = taskList.get(2);

		EditRecurringCommand editRecurringCommand = new EditRecurringCommand(addedTask_1.getId(), "title",
				"it works perfectly");
		
		// check if the EditRecurringCommand returns the right status message
		assertEquals("A series of recurring tasks has been edited", editRecurringCommand.execute());

		// check if all recurring tasks have been edited
		assertEquals("it works perfectly", addedTask_1.getTitle());
		assertEquals("it works perfectly", addedTask_2.getTitle());
		assertEquals("it works perfectly", addedTask_3.getTitle());

	}

	@Test
	public void testEditRecurringMiddleTask() {

		testAddRecurring();

		Item addedTask_1 = taskList.get(0);
		Item addedTask_2 = taskList.get(1);
		Item addedTask_3 = taskList.get(2);

		EditRecurringCommand editRecurringCommand = new EditRecurringCommand(addedTask_2.getId(), "title",
				"it works perfectly");
		
		// check if the EditRecurringCommand returns the right status message
		assertEquals("A series of recurring tasks has been edited", editRecurringCommand.execute());

		// check if all recurring tasks have been edited
		assertEquals("it works perfectly", addedTask_1.getTitle());
		assertEquals("it works perfectly", addedTask_2.getTitle());
		assertEquals("it works perfectly", addedTask_3.getTitle());

	}

	@Test
	public void testEditRecurringLastTask() {

		testAddRecurring();

		Item addedTask_1 = taskList.get(0);
		Item addedTask_2 = taskList.get(1);
		Item addedTask_3 = taskList.get(2);

		EditRecurringCommand editRecurringCommand = new EditRecurringCommand(addedTask_3.getId(), "title",
				"it works perfectly");
		
		// check if the EditRecurringCommand returns the right status message
		assertEquals("A series of recurring tasks has been edited", editRecurringCommand.execute());

		// check if all recurring tasks have been edited
		assertEquals("it works perfectly", addedTask_1.getTitle());
		assertEquals("it works perfectly", addedTask_2.getTitle());
		assertEquals("it works perfectly", addedTask_3.getTitle());

	}

	@Test
	public void testUndoAddRecurring() {

		testAddRecurring();

		UndoCommand undo = new UndoCommand();
		
		// check if the UndoCommand returns the right status message
		assertEquals("Previous action has been successfully undone", undo.execute());

		// check if all recurring tasks have been removed by undo
		assertEquals(0, taskList.size());
     
	}

	@Test
	public void testUndoDelRecurring() {

		testAddRecurring();

		Item firstTask = taskList.get(0);

		DelRecurringCommand deleteRecur = new DelRecurringCommand(firstTask.getId());
		assertEquals("A series of recurring tasks has been deleted", deleteRecur.execute());

		UndoCommand undo = new UndoCommand();
		
		// check if the UndoCommand returns the right status message
		assertEquals("Previous action has been successfully undone", undo.execute());

		// check if all recurring tasks have been added back by undo
		assertEquals(3, taskList.size());

		Item addedTask_1 = taskList.get(0);
		Item addedTask_2 = taskList.get(1);
		Item addedTask_3 = taskList.get(2);

		assertEquals("do project", addedTask_1.getTitle());
		assertEquals("do project", addedTask_2.getTitle());
		assertEquals("do project", addedTask_3.getTitle());
	}

	@Test
	public void testUndoEditRecurring() {

		testEditRecurringTitle();

		UndoCommand undo = new UndoCommand();
		
		// check if the UndoCommand returns the right status message
		assertEquals("Previous action has been successfully undone", undo.execute());

		// check if all recurring tasks have been changed back by undo
		assertEquals(3, taskList.size());

		Item addedTask_1 = taskList.get(0);
		Item addedTask_2 = taskList.get(1);
		Item addedTask_3 = taskList.get(2);

		assertEquals("do project", addedTask_1.getTitle());
		assertEquals("do project", addedTask_2.getTitle());
		assertEquals("do project", addedTask_3.getTitle());
	}

	/**
	 * Recurring tasks are linked by the circular doubly linked list concept.
	 * Thus, pointers must be updated if the middle node is deleted. This test
	 * adds 3 tasks and deletes the middle one to test the pointers are being
	 * updated.
	 */
	@Test
	public void testRecurringLinkage() {

		testAddRecurring();

		Item addedTask_1 = taskList.get(0);
		Item addedTask_2 = taskList.get(1);
		Item addedTask_3 = taskList.get(2);

		UndoCommand undo = new UndoCommand();
		DelCommand delete = new DelCommand(addedTask_2.getId());

		// check if the correct status message is returned
		assertEquals(addedTask_2.getId() + " has been deleted from Task", delete.execute());
		assertEquals(2, taskList.size());

		DelRecurringCommand delRecurring_1 = new DelRecurringCommand(addedTask_1.getId());
		assertEquals("A series of recurring tasks has been deleted", delRecurring_1.execute());
		assertEquals(0, taskList.size());

		assertEquals("Previous action has been successfully undone", undo.execute());
		assertEquals("Previous action has been successfully undone", undo.execute());

		// check if linkage is restored if deleted middle task is added back by
		// undo
		assertEquals(3, taskList.size());
		DelRecurringCommand delRecurring_2 = new DelRecurringCommand(addedTask_2.getId());
		assertEquals("A series of recurring tasks has been deleted", delRecurring_2.execute());
		assertEquals(0, taskList.size());
	}
}
```
###### src\Test\TestPOMPOM.java
``` java
 */
public class TestPOMPOM {

	/** Parameters **/
	POMPOM pompom;
	ArrayList<Item> taskList;

	/**
	 * This method initializes POMPOM class and clears the storage for testing.
	 */
	@Before
	public void initialize() {
		pompom = new POMPOM();
		taskList = POMPOM.getStorage().getTaskList();
		taskList.clear();
	}

	@Test
	public void testStatusPending() {

		pompom.execute("add do cs3241 f:tomorrow e:next friday");
		pompom.execute("add do cs3241 f:next monday");

		Item firstTask = taskList.get(0);
		Item secondTask = taskList.get(1);

		POMPOM.refreshStatus();

		/**
		 * check if the statuses are pending as current date is before start
		 * date
		 */
		assertEquals(POMPOM.STATUS_PENDING, firstTask.getStatus());
		assertEquals(POMPOM.STATUS_PENDING, secondTask.getStatus());

	}

	@Test
	public void testStatusOngoing() {

		pompom.execute("add do cs3241 f:now e:next friday");
		pompom.execute("add do cs3241 f:now");
		pompom.execute("add do cs3241 e:next tuesday");

		Item firstTask = taskList.get(0);
		Item secondTask = taskList.get(1);
		Item thirdTask = taskList.get(2);

		POMPOM.refreshStatus();

		/**
		 * check if the statuses are ongoing as current date is within the start
		 * and end date specified
		 */
		assertEquals(POMPOM.STATUS_ONGOING, firstTask.getStatus());
		assertEquals(POMPOM.STATUS_ONGOING, secondTask.getStatus());
		assertEquals(POMPOM.STATUS_ONGOING, thirdTask.getStatus());

	}

	@Test
	public void testStatusOverdue() {

		pompom.execute("add do cs3241 f:yesterday e:yesterday");
		pompom.execute("add do cs3241 e:last monday");

		Item firstTask = taskList.get(0);
		Item secondTask = taskList.get(1);

		POMPOM.refreshStatus();

		/**
		 * check if the statuses are overdue as current date after end date
		 */
		assertEquals(POMPOM.STATUS_OVERDUE, firstTask.getStatus());
		assertEquals(POMPOM.STATUS_OVERDUE, secondTask.getStatus());

	}

	@Test
	public void testStatusFloating() {

		pompom.execute("add do cs3241");
		pompom.execute("add do cs2103t");

		Item firstTask = taskList.get(0);
		Item secondTask = taskList.get(1);

		POMPOM.refreshStatus();

		/**
		 * check if the statuses are floating as start and end date are not
		 * specified
		 */
		assertEquals(POMPOM.STATUS_FLOATING, firstTask.getStatus());
		assertEquals(POMPOM.STATUS_FLOATING, secondTask.getStatus());

	}

	@Test
	public void testStatusCompleted() {

		pompom.execute("add do cs3241 f:now e:next friday");
		pompom.execute("add do cs3241 f:now");
		pompom.execute("add do cs3241 e:next tuesday");

		Item firstTask = taskList.get(0);
		Item secondTask = taskList.get(1);
		Item thirdTask = taskList.get(2);

		for (int i = 0; i < 3; i++) {
			Item currentTask = taskList.get(i);
			EditCommand command = new EditCommand(currentTask.getId(), "status", POMPOM.STATUS_COMPLETED);
			command.execute();
		}

		POMPOM.refreshStatus();

		/**
		 * check if the statuses remain completed as edit command was used
		 */
		assertEquals(POMPOM.STATUS_COMPLETED, firstTask.getStatus());
		assertEquals(POMPOM.STATUS_COMPLETED, secondTask.getStatus());
		assertEquals(POMPOM.STATUS_COMPLETED, thirdTask.getStatus());

	}

	@Test
	public void testEventStatusCompleted() {

		pompom.execute("event clubbing f:last wed 10pm e:last thurs 4am");
		pompom.execute("event clubbing f:now e:tomorrow 4am");
		pompom.execute("event clubbing f:next wed 10pm e:next thurs 4am");

		Item firstEvent = taskList.get(0);
		Item secondEvent = taskList.get(1);
		Item thirdEvent = taskList.get(2);

		POMPOM.refreshStatus();

		assertEquals(POMPOM.STATUS_COMPLETED, firstEvent.getStatus());
		assertEquals(POMPOM.STATUS_ONGOING, secondEvent.getStatus());
		assertEquals(POMPOM.STATUS_PENDING, thirdEvent.getStatus());

	}

}
```
